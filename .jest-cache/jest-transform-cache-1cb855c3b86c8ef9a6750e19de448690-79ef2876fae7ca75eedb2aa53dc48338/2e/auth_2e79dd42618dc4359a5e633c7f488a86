26460d98b3a30c896d39aa8808c67dfc
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "StravaAuth", {
    enumerable: true,
    get: function() {
        return StravaAuth;
    }
});
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
class StravaAuth {
    constructor(isServer = false){
        this.supabaseClient = null;
        this.isServer = isServer;
    }
    async getSupabase() {
        if (!this.supabaseClient) {
            if (this.isServer) {
                const { createClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../supabase/server")));
                this.supabaseClient = await createClient();
            } else {
                const { createClient: createBrowserClient } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../supabase/client")));
                this.supabaseClient = createBrowserClient();
            }
        }
        return this.supabaseClient;
    }
    /**
   * Store tokens after successful OAuth exchange
   */ async storeTokens(userId, authResponse) {
        const supabase = await this.getSupabase();
        const tokenData = {
            user_id: userId,
            access_token: authResponse.access_token,
            refresh_token: authResponse.refresh_token,
            token_type: authResponse.token_type,
            expires_at: new Date(authResponse.expires_at * 1000).toISOString(),
            expires_in: authResponse.expires_in,
            strava_athlete_id: authResponse.athlete.id,
            athlete_firstname: authResponse.athlete.firstname,
            athlete_lastname: authResponse.athlete.lastname,
            athlete_profile: authResponse.athlete.profile
        };
        const { error } = await supabase.from('strava_tokens').upsert(tokenData, {
            onConflict: 'user_id',
            ignoreDuplicates: false
        });
        if (error) {
            console.error('Error storing Strava tokens:', error);
            throw new Error('Failed to store authentication tokens');
        }
    }
    /**
   * Get stored tokens for a user
   */ async getTokens(userId) {
        const supabase = await this.getSupabase();
        const { data, error } = await supabase.from('strava_tokens').select('*').eq('user_id', userId).single();
        if (error) {
            if (error.code === 'PGRST116') {
                // No tokens found - user not connected
                return null;
            }
            console.error('Error fetching Strava tokens:', error);
            throw new Error('Failed to fetch authentication tokens');
        }
        return data;
    }
    /**
   * Check if user is connected to Strava and tokens are valid
   */ async isConnected(userId) {
        try {
            const tokens = await this.getTokens(userId);
            if (!tokens) return false;
            // Check if tokens are expired
            const expiresAt = new Date(tokens.expires_at);
            const now = new Date();
            const bufferTime = 5 * 60 * 1000; // 5 minutes buffer
            return expiresAt.getTime() > now.getTime() + bufferTime;
        } catch (error) {
            console.error('Error checking Strava connection:', error);
            return false;
        }
    }
    /**
   * Get valid access token (refresh if needed)
   */ async getValidAccessToken(userId) {
        try {
            const tokens = await this.getTokens(userId);
            if (!tokens) return null;
            // Check if token needs refresh
            const expiresAt = new Date(tokens.expires_at);
            const now = new Date();
            const bufferTime = 10 * 60 * 1000; // 10 minutes buffer
            if (expiresAt.getTime() <= now.getTime() + bufferTime) {
                // Token expired or expiring soon, refresh it
                const refreshedTokens = await this.refreshTokens(tokens.refresh_token, userId);
                return refreshedTokens?.access_token || null;
            }
            return tokens.access_token;
        } catch (error) {
            console.error('Error getting valid access token:', error);
            return null;
        }
    }
    /**
   * Refresh expired tokens
   */ async refreshTokens(refreshToken, userId) {
        try {
            const response = await fetch('https://www.strava.com/oauth/token', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    client_id: process.env.NEXT_PUBLIC_STRAVA_CLIENT_ID,
                    client_secret: process.env.STRAVA_CLIENT_SECRET,
                    grant_type: 'refresh_token',
                    refresh_token: refreshToken
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to refresh token: ${response.statusText}`);
            }
            const authResponse = await response.json();
            // Store the refreshed tokens
            await this.storeTokens(userId, authResponse);
            // Return the updated tokens
            return await this.getTokens(userId);
        } catch (error) {
            console.error('Error refreshing Strava tokens:', error);
            // If refresh fails, remove the invalid tokens
            await this.disconnectUser(userId);
            return null;
        }
    }
    /**
   * Disconnect user from Strava (remove tokens)
   */ async disconnectUser(userId) {
        const supabase = await this.getSupabase();
        const { error } = await supabase.from('strava_tokens').delete().eq('user_id', userId);
        if (error) {
            console.error('Error disconnecting user from Strava:', error);
            throw new Error('Failed to disconnect from Strava');
        }
    }
    /**
   * Get connection status with user info
   */ async getConnectionStatus(userId) {
        try {
            console.log('🔍 Checking connection status for user:', userId);
            const tokens = await this.getTokens(userId);
            if (!tokens) {
                console.log('❌ No tokens found for user');
                return {
                    connected: false
                };
            }
            console.log('✅ Tokens found, checking if connected...');
            const connected = await this.isConnected(userId);
            console.log('🔗 Connection status:', connected, 'expires at:', tokens.expires_at);
            return {
                connected,
                athlete: {
                    id: tokens.strava_athlete_id,
                    firstname: tokens.athlete_firstname,
                    lastname: tokens.athlete_lastname,
                    profile: tokens.athlete_profile
                },
                expiresAt: tokens.expires_at
            };
        } catch (error) {
            console.error('Error getting connection status:', error);
            return {
                connected: false
            };
        }
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdGlhbWFcXERlc2t0b3BcXENvZGluZ1xcZW5kdXJvcmV2YW1wXFxsaWJcXHN0cmF2YVxcYXV0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFN1cGFiYXNlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcclxuaW1wb3J0IHR5cGUgeyBTdHJhdmFBdXRoUmVzcG9uc2UgfSBmcm9tICdAL2xpYi9zdHJhdmEvdHlwZXMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdHJhdmFUb2tlbnMge1xyXG4gIGlkPzogc3RyaW5nO1xyXG4gIHVzZXJfaWQ6IHN0cmluZztcclxuICBhY2Nlc3NfdG9rZW46IHN0cmluZztcclxuICByZWZyZXNoX3Rva2VuOiBzdHJpbmc7XHJcbiAgdG9rZW5fdHlwZTogc3RyaW5nO1xyXG4gIGV4cGlyZXNfYXQ6IHN0cmluZztcclxuICBleHBpcmVzX2luOiBudW1iZXI7XHJcbiAgc3RyYXZhX2F0aGxldGVfaWQ6IG51bWJlcjtcclxuICBhdGhsZXRlX2ZpcnN0bmFtZT86IHN0cmluZztcclxuICBhdGhsZXRlX2xhc3RuYW1lPzogc3RyaW5nO1xyXG4gIGF0aGxldGVfcHJvZmlsZT86IHN0cmluZztcclxuICBzY29wZT86IHN0cmluZztcclxuICBjcmVhdGVkX2F0Pzogc3RyaW5nO1xyXG4gIHVwZGF0ZWRfYXQ/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTdHJhdmFBdXRoIHtcclxuICBwcml2YXRlIHN1cGFiYXNlQ2xpZW50OiBTdXBhYmFzZUNsaWVudCB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgaXNTZXJ2ZXI6IGJvb2xlYW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKGlzU2VydmVyID0gZmFsc2UpIHtcclxuICAgIHRoaXMuaXNTZXJ2ZXIgPSBpc1NlcnZlcjtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0U3VwYWJhc2UoKTogUHJvbWlzZTxTdXBhYmFzZUNsaWVudD4ge1xyXG4gICAgaWYgKCF0aGlzLnN1cGFiYXNlQ2xpZW50KSB7XHJcbiAgICAgIGlmICh0aGlzLmlzU2VydmVyKSB7XHJcbiAgICAgICAgY29uc3QgeyBjcmVhdGVDbGllbnQgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvc3VwYWJhc2Uvc2VydmVyJyk7XHJcbiAgICAgICAgdGhpcy5zdXBhYmFzZUNsaWVudCA9IGF3YWl0IGNyZWF0ZUNsaWVudCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHsgY3JlYXRlQ2xpZW50OiBjcmVhdGVCcm93c2VyQ2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoJ0AvbGliL3N1cGFiYXNlL2NsaWVudCcpO1xyXG4gICAgICAgIHRoaXMuc3VwYWJhc2VDbGllbnQgPSBjcmVhdGVCcm93c2VyQ2xpZW50KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnN1cGFiYXNlQ2xpZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcmUgdG9rZW5zIGFmdGVyIHN1Y2Nlc3NmdWwgT0F1dGggZXhjaGFuZ2VcclxuICAgKi9cclxuICBhc3luYyBzdG9yZVRva2Vucyh1c2VySWQ6IHN0cmluZywgYXV0aFJlc3BvbnNlOiBTdHJhdmFBdXRoUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgdGhpcy5nZXRTdXBhYmFzZSgpO1xyXG4gICAgXHJcbiAgICBjb25zdCB0b2tlbkRhdGE6IE9taXQ8U3RyYXZhVG9rZW5zLCAnaWQnIHwgJ2NyZWF0ZWRfYXQnIHwgJ3VwZGF0ZWRfYXQnPiA9IHtcclxuICAgICAgdXNlcl9pZDogdXNlcklkLFxyXG4gICAgICBhY2Nlc3NfdG9rZW46IGF1dGhSZXNwb25zZS5hY2Nlc3NfdG9rZW4sXHJcbiAgICAgIHJlZnJlc2hfdG9rZW46IGF1dGhSZXNwb25zZS5yZWZyZXNoX3Rva2VuLFxyXG4gICAgICB0b2tlbl90eXBlOiBhdXRoUmVzcG9uc2UudG9rZW5fdHlwZSxcclxuICAgICAgZXhwaXJlc19hdDogbmV3IERhdGUoYXV0aFJlc3BvbnNlLmV4cGlyZXNfYXQgKiAxMDAwKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBleHBpcmVzX2luOiBhdXRoUmVzcG9uc2UuZXhwaXJlc19pbixcclxuICAgICAgc3RyYXZhX2F0aGxldGVfaWQ6IGF1dGhSZXNwb25zZS5hdGhsZXRlLmlkLFxyXG4gICAgICBhdGhsZXRlX2ZpcnN0bmFtZTogYXV0aFJlc3BvbnNlLmF0aGxldGUuZmlyc3RuYW1lLFxyXG4gICAgICBhdGhsZXRlX2xhc3RuYW1lOiBhdXRoUmVzcG9uc2UuYXRobGV0ZS5sYXN0bmFtZSxcclxuICAgICAgYXRobGV0ZV9wcm9maWxlOiBhdXRoUmVzcG9uc2UuYXRobGV0ZS5wcm9maWxlLFxyXG4gICAgICAvLyBzY29wZTogYXV0aFJlc3BvbnNlLnNjb3BlLCAvLyBBZGQgaWYgU3RyYXZhIHJldHVybnMgc2NvcGVcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3N0cmF2YV90b2tlbnMnKVxyXG4gICAgICAudXBzZXJ0KHRva2VuRGF0YSwgeyBcclxuICAgICAgICBvbkNvbmZsaWN0OiAndXNlcl9pZCcsXHJcbiAgICAgICAgaWdub3JlRHVwbGljYXRlczogZmFsc2UgXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdG9yaW5nIFN0cmF2YSB0b2tlbnM6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzdG9yZSBhdXRoZW50aWNhdGlvbiB0b2tlbnMnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBzdG9yZWQgdG9rZW5zIGZvciBhIHVzZXJcclxuICAgKi9cclxuICBhc3luYyBnZXRUb2tlbnModXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPFN0cmF2YVRva2VucyB8IG51bGw+IHtcclxuICAgIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgdGhpcy5nZXRTdXBhYmFzZSgpO1xyXG4gICAgXHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnc3RyYXZhX3Rva2VucycpXHJcbiAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXHJcbiAgICAgIC5zaW5nbGUoKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHtcclxuICAgICAgICAvLyBObyB0b2tlbnMgZm91bmQgLSB1c2VyIG5vdCBjb25uZWN0ZWRcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBTdHJhdmEgdG9rZW5zOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggYXV0aGVudGljYXRpb24gdG9rZW5zJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB1c2VyIGlzIGNvbm5lY3RlZCB0byBTdHJhdmEgYW5kIHRva2VucyBhcmUgdmFsaWRcclxuICAgKi9cclxuICBhc3luYyBpc0Nvbm5lY3RlZCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdG9rZW5zID0gYXdhaXQgdGhpcy5nZXRUb2tlbnModXNlcklkKTtcclxuICAgICAgaWYgKCF0b2tlbnMpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHRva2VucyBhcmUgZXhwaXJlZFxyXG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBuZXcgRGF0ZSh0b2tlbnMuZXhwaXJlc19hdCk7XHJcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlclRpbWUgPSA1ICogNjAgKiAxMDAwOyAvLyA1IG1pbnV0ZXMgYnVmZmVyXHJcblxyXG4gICAgICByZXR1cm4gZXhwaXJlc0F0LmdldFRpbWUoKSA+IChub3cuZ2V0VGltZSgpICsgYnVmZmVyVGltZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBTdHJhdmEgY29ubmVjdGlvbjonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB2YWxpZCBhY2Nlc3MgdG9rZW4gKHJlZnJlc2ggaWYgbmVlZGVkKVxyXG4gICAqL1xyXG4gIGFzeW5jIGdldFZhbGlkQWNjZXNzVG9rZW4odXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IHRoaXMuZ2V0VG9rZW5zKHVzZXJJZCk7XHJcbiAgICAgIGlmICghdG9rZW5zKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHRva2VuIG5lZWRzIHJlZnJlc2hcclxuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gbmV3IERhdGUodG9rZW5zLmV4cGlyZXNfYXQpO1xyXG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICBjb25zdCBidWZmZXJUaW1lID0gMTAgKiA2MCAqIDEwMDA7IC8vIDEwIG1pbnV0ZXMgYnVmZmVyXHJcblxyXG4gICAgICBpZiAoZXhwaXJlc0F0LmdldFRpbWUoKSA8PSAobm93LmdldFRpbWUoKSArIGJ1ZmZlclRpbWUpKSB7XHJcbiAgICAgICAgLy8gVG9rZW4gZXhwaXJlZCBvciBleHBpcmluZyBzb29uLCByZWZyZXNoIGl0XHJcbiAgICAgICAgY29uc3QgcmVmcmVzaGVkVG9rZW5zID0gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW5zKHRva2Vucy5yZWZyZXNoX3Rva2VuLCB1c2VySWQpO1xyXG4gICAgICAgIHJldHVybiByZWZyZXNoZWRUb2tlbnM/LmFjY2Vzc190b2tlbiB8fCBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdG9rZW5zLmFjY2Vzc190b2tlbjtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdmFsaWQgYWNjZXNzIHRva2VuOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWZyZXNoIGV4cGlyZWQgdG9rZW5zXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyByZWZyZXNoVG9rZW5zKHJlZnJlc2hUb2tlbjogc3RyaW5nLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8U3RyYXZhVG9rZW5zIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly93d3cuc3RyYXZhLmNvbS9vYXV0aC90b2tlbicsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgY2xpZW50X2lkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVFJBVkFfQ0xJRU5UX0lELFxyXG4gICAgICAgICAgY2xpZW50X3NlY3JldDogcHJvY2Vzcy5lbnYuU1RSQVZBX0NMSUVOVF9TRUNSRVQsXHJcbiAgICAgICAgICBncmFudF90eXBlOiAncmVmcmVzaF90b2tlbicsXHJcbiAgICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4sXHJcbiAgICAgICAgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlZnJlc2ggdG9rZW46ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYXV0aFJlc3BvbnNlOiBTdHJhdmFBdXRoUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdG9yZSB0aGUgcmVmcmVzaGVkIHRva2Vuc1xyXG4gICAgICBhd2FpdCB0aGlzLnN0b3JlVG9rZW5zKHVzZXJJZCwgYXV0aFJlc3BvbnNlKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFJldHVybiB0aGUgdXBkYXRlZCB0b2tlbnNcclxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0VG9rZW5zKHVzZXJJZCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWZyZXNoaW5nIFN0cmF2YSB0b2tlbnM6JywgZXJyb3IpO1xyXG4gICAgICBcclxuICAgICAgLy8gSWYgcmVmcmVzaCBmYWlscywgcmVtb3ZlIHRoZSBpbnZhbGlkIHRva2Vuc1xyXG4gICAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3RVc2VyKHVzZXJJZCk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzY29ubmVjdCB1c2VyIGZyb20gU3RyYXZhIChyZW1vdmUgdG9rZW5zKVxyXG4gICAqL1xyXG4gIGFzeW5jIGRpc2Nvbm5lY3RVc2VyKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBzdXBhYmFzZSA9IGF3YWl0IHRoaXMuZ2V0U3VwYWJhc2UoKTtcclxuICAgIFxyXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3N0cmF2YV90b2tlbnMnKVxyXG4gICAgICAuZGVsZXRlKClcclxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGlzY29ubmVjdGluZyB1c2VyIGZyb20gU3RyYXZhOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGlzY29ubmVjdCBmcm9tIFN0cmF2YScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGNvbm5lY3Rpb24gc3RhdHVzIHdpdGggdXNlciBpbmZvXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0Q29ubmVjdGlvblN0YXR1cyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8e1xyXG4gICAgY29ubmVjdGVkOiBib29sZWFuO1xyXG4gICAgYXRobGV0ZT86IHtcclxuICAgICAgaWQ6IG51bWJlcjtcclxuICAgICAgZmlyc3RuYW1lPzogc3RyaW5nO1xyXG4gICAgICBsYXN0bmFtZT86IHN0cmluZztcclxuICAgICAgcHJvZmlsZT86IHN0cmluZztcclxuICAgIH07XHJcbiAgICBleHBpcmVzQXQ/OiBzdHJpbmc7XHJcbiAgfT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CflI0gQ2hlY2tpbmcgY29ubmVjdGlvbiBzdGF0dXMgZm9yIHVzZXI6JywgdXNlcklkKTtcclxuICAgICAgY29uc3QgdG9rZW5zID0gYXdhaXQgdGhpcy5nZXRUb2tlbnModXNlcklkKTtcclxuICAgICAgXHJcbiAgICAgIGlmICghdG9rZW5zKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ+KdjCBObyB0b2tlbnMgZm91bmQgZm9yIHVzZXInKTtcclxuICAgICAgICByZXR1cm4geyBjb25uZWN0ZWQ6IGZhbHNlIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVG9rZW5zIGZvdW5kLCBjaGVja2luZyBpZiBjb25uZWN0ZWQuLi4nKTtcclxuICAgICAgY29uc3QgY29ubmVjdGVkID0gYXdhaXQgdGhpcy5pc0Nvbm5lY3RlZCh1c2VySWQpO1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UlyBDb25uZWN0aW9uIHN0YXR1czonLCBjb25uZWN0ZWQsICdleHBpcmVzIGF0OicsIHRva2Vucy5leHBpcmVzX2F0KTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgY29ubmVjdGVkLFxyXG4gICAgICAgIGF0aGxldGU6IHtcclxuICAgICAgICAgIGlkOiB0b2tlbnMuc3RyYXZhX2F0aGxldGVfaWQsXHJcbiAgICAgICAgICBmaXJzdG5hbWU6IHRva2Vucy5hdGhsZXRlX2ZpcnN0bmFtZSxcclxuICAgICAgICAgIGxhc3RuYW1lOiB0b2tlbnMuYXRobGV0ZV9sYXN0bmFtZSxcclxuICAgICAgICAgIHByb2ZpbGU6IHRva2Vucy5hdGhsZXRlX3Byb2ZpbGUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleHBpcmVzQXQ6IHRva2Vucy5leHBpcmVzX2F0LFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBjb25uZWN0aW9uIHN0YXR1czonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7IGNvbm5lY3RlZDogZmFsc2UgfTtcclxuICAgIH1cclxuICB9XHJcbn0gIl0sIm5hbWVzIjpbIlN0cmF2YUF1dGgiLCJjb25zdHJ1Y3RvciIsImlzU2VydmVyIiwic3VwYWJhc2VDbGllbnQiLCJnZXRTdXBhYmFzZSIsImNyZWF0ZUNsaWVudCIsImNyZWF0ZUJyb3dzZXJDbGllbnQiLCJzdG9yZVRva2VucyIsInVzZXJJZCIsImF1dGhSZXNwb25zZSIsInN1cGFiYXNlIiwidG9rZW5EYXRhIiwidXNlcl9pZCIsImFjY2Vzc190b2tlbiIsInJlZnJlc2hfdG9rZW4iLCJ0b2tlbl90eXBlIiwiZXhwaXJlc19hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImV4cGlyZXNfaW4iLCJzdHJhdmFfYXRobGV0ZV9pZCIsImF0aGxldGUiLCJpZCIsImF0aGxldGVfZmlyc3RuYW1lIiwiZmlyc3RuYW1lIiwiYXRobGV0ZV9sYXN0bmFtZSIsImxhc3RuYW1lIiwiYXRobGV0ZV9wcm9maWxlIiwicHJvZmlsZSIsImVycm9yIiwiZnJvbSIsInVwc2VydCIsIm9uQ29uZmxpY3QiLCJpZ25vcmVEdXBsaWNhdGVzIiwiY29uc29sZSIsIkVycm9yIiwiZ2V0VG9rZW5zIiwiZGF0YSIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwiY29kZSIsImlzQ29ubmVjdGVkIiwidG9rZW5zIiwiZXhwaXJlc0F0Iiwibm93IiwiYnVmZmVyVGltZSIsImdldFRpbWUiLCJnZXRWYWxpZEFjY2Vzc1Rva2VuIiwicmVmcmVzaGVkVG9rZW5zIiwicmVmcmVzaFRva2VucyIsInJlZnJlc2hUb2tlbiIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjbGllbnRfaWQiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1RSQVZBX0NMSUVOVF9JRCIsImNsaWVudF9zZWNyZXQiLCJTVFJBVkFfQ0xJRU5UX1NFQ1JFVCIsImdyYW50X3R5cGUiLCJvayIsInN0YXR1c1RleHQiLCJqc29uIiwiZGlzY29ubmVjdFVzZXIiLCJkZWxldGUiLCJnZXRDb25uZWN0aW9uU3RhdHVzIiwibG9nIiwiY29ubmVjdGVkIl0sIm1hcHBpbmdzIjoiOzs7OytCQW9CYUE7OztlQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTixNQUFNQTtJQUlYQyxZQUFZQyxXQUFXLEtBQUssQ0FBRTthQUh0QkMsaUJBQXdDO1FBSTlDLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtJQUNsQjtJ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