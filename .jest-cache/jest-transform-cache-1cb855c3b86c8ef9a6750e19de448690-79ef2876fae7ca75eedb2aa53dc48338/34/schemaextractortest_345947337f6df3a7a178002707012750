06d45dc1ff234d1e9c13b14f352c1db7
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "generateSchemaReport", {
    enumerable: true,
    get: function() {
        return generateSchemaReport;
    }
});
const _supabasejs = require("@supabase/supabase-js");
describe('Schema Extractor', ()=>{
    let supabase;
    beforeAll(()=>{
        if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_URL.includes('test.supabase.co')) {
            console.log('‚ö†Ô∏è  No real database credentials - skipping schema extraction');
            return;
        }
        supabase = (0, _supabasejs.createClient)(process.env.NEXT_PUBLIC_SUPABASE_URL, process.env.SUPABASE_SERVICE_ROLE_KEY);
    });
    test('extract complete database schema', async ()=>{
        if (!supabase) {
            console.log('Skipping - no database connection');
            return;
        }
        console.log('\nüîç EXTRACTING DATABASE SCHEMA...\n');
        // Get all tables
        const { data: tables, error: tablesError } = await supabase.rpc('get_table_info');
        if (tablesError) {
            // Fallback to manual query
            const { data: tablesData, error: fallbackError } = await supabase.from('information_schema.tables').select('table_name').eq('table_schema', 'public').eq('table_type', 'BASE TABLE');
            if (fallbackError) {
                console.log('‚ùå Could not get table list:', fallbackError.message);
                return;
            }
            // Extract schema for each table manually
            for (const table of tablesData || []){
                await extractTableSchema(supabase, table.table_name);
            }
        }
        expect(true).toBe(true) // Test always passes, we just want the output
        ;
    });
});
async function extractTableSchema(supabase, tableName) {
    console.log(`\nüìä TABLE: ${tableName.toUpperCase()}`);
    console.log('=' + '='.repeat(tableName.length + 8));
    // Get columns
    const { data: columns, error: columnsError } = await supabase.rpc('get_table_columns', {
        table_name_input: tableName
    });
    if (columnsError) {
        // Fallback to information_schema query
        const query = `
      SELECT 
        column_name,
        data_type,
        is_nullable,
        column_default,
        character_maximum_length,
        numeric_precision,
        numeric_scale
      FROM information_schema.columns 
      WHERE table_schema = 'public' 
        AND table_name = '${tableName}'
      ORDER BY ordinal_position
    `;
        const { data: fallbackColumns, error: fallbackError } = await supabase.rpc('exec_sql', {
            sql: query
        });
        if (fallbackError) {
            console.log(`‚ùå Could not get columns for ${tableName}:`, fallbackError.message);
            return;
        }
        // Display columns
        if (fallbackColumns && fallbackColumns.length > 0) {
            fallbackColumns.forEach((col)=>{
                const nullable = col.is_nullable === 'YES' ? 'NULL' : 'NOT NULL';
                const defaultVal = col.column_default ? ` DEFAULT ${col.column_default}` : '';
                console.log(`  ${col.column_name.padEnd(25)} ${col.data_type.padEnd(15)} ${nullable}${defaultVal}`);
            });
        }
    } else {
        // Use RPC result
        console.log('Columns:', columns);
    }
    // Get constraints (PKs, FKs, etc.)
    await getTableConstraints(supabase, tableName);
    // Get indexes
    await getTableIndexes(supabase, tableName);
    // Get sample data count
    try {
        const { count } = await supabase.from(tableName).select('*', {
            count: 'exact',
            head: true
        });
        console.log(`üìà Record count: ${count || 0}`);
    } catch (e) {
        console.log('üìà Record count: Unable to query');
    }
}
async function getTableConstraints(supabase, tableName) {
    const constraintsQuery = `
    SELECT 
      tc.constraint_name,
      tc.constraint_type,
      ku.column_name,
      ccu.table_name AS foreign_table_name,
      ccu.column_name AS foreign_column_name
    FROM information_schema.table_constraints tc
    LEFT JOIN information_schema.key_column_usage ku 
      ON tc.constraint_name = ku.constraint_name
    LEFT JOIN information_schema.constraint_column_usage ccu 
      ON tc.constraint_name = ccu.constraint_name
    WHERE tc.table_schema = 'public' 
      AND tc.table_name = '${tableName}'
    ORDER BY tc.constraint_type, ku.column_name
  `;
    try {
        const { data: constraints } = await supabase.rpc('exec_sql', {
            sql: constraintsQuery
        });
        if (constraints && constraints.length > 0) {
            console.log('\nüîó Constraints:');
            constraints.forEach((constraint)=>{
                if (constraint.constraint_type === 'PRIMARY KEY') {
                    console.log(`  üîë PRIMARY KEY: ${constraint.column_name}`);
                } else if (constraint.constraint_type === 'FOREIGN KEY') {
                    console.log(`  üîó FOREIGN KEY: ${constraint.column_name} ‚Üí ${constraint.foreign_table_name}(${constraint.foreign_column_name})`);
                } else if (constraint.constraint_type === 'UNIQUE') {
                    console.log(`  ‚≠ê UNIQUE: ${constraint.column_name}`);
                }
            });
        }
    } catch (e) {
        console.log('Could not get constraints');
    }
}
async function getTableIndexes(supabase, tableName) {
    const indexQuery = `
    SELECT 
      indexname,
      indexdef
    FROM pg_indexes 
    WHERE schemaname = 'public' 
      AND tablename = '${tableName}'
      AND indexname NOT LIKE '%pkey'
  `;
    try {
        const { data: indexes } = await supabase.rpc('exec_sql', {
            sql: indexQuery
        });
        if (indexes && indexes.length > 0) {
            console.log('\nüìä Indexes:');
            indexes.forEach((index)=>{
                console.log(`  üìä ${index.indexname}: ${index.indexdef}`);
            });
        }
    } catch (e) {
        console.log('Could not get indexes');
    }
}
async function generateSchemaReport() {
    if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_URL.includes('test.supabase.co')) {
        console.log('‚ö†Ô∏è  No real database credentials available');
        return null;
    }
    const supabase = (0, _supabasejs.createClient)(process.env.NEXT_PUBLIC_SUPABASE_URL, process.env.SUPABASE_SERVICE_ROLE_KEY);
    // Get simplified schema info
    const schema = {
        tables: {},
        relationships: [],
        summary: {}
    };
    const tables = [
        'activities',
        'strava_tokens',
        'sync_state',
        'goal_types',
        'user_goals',
        'goal_progress',
        'user_onboarding'
    ];
    for (const tableName of tables){
        try {
            const { count } = await supabase.from(tableName).select('*', {
                count: 'exact',
                head: true
            });
            schema.tables[tableName] = {
                exists: true,
                recordCount: count || 0
            };
        } catch (error) {
            schema.tables[tableName] = {
                exists: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }
    console.log('\nüìã SCHEMA SUMMARY');
    console.log('================');
    Object.entries(schema.tables).forEach(([table, info])=>{
        const status = info.exists ? '‚úÖ' : '‚ùå';
        const count = info.exists ? `(${info.recordCount} records)` : `(${info.error})`;
        console.log(`${status} ${table.padEnd(20)} ${count}`);
    });
    return schema;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdGlhbWFcXERlc2t0b3BcXENvZGluZ1xcZW5kdXJvcmV2YW1wXFxfX3Rlc3RzX19cXGRhdGFiYXNlXFxzY2hlbWEtZXh0cmFjdG9yLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xyXG5cclxuZGVzY3JpYmUoJ1NjaGVtYSBFeHRyYWN0b3InLCAoKSA9PiB7XHJcbiAgbGV0IHN1cGFiYXNlOiBhbnlcclxuICBcclxuICBiZWZvcmVBbGwoKCkgPT4ge1xyXG4gICAgaWYgKCFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgfHwgXHJcbiAgICAgICAgIXByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkgfHxcclxuICAgICAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwuaW5jbHVkZXMoJ3Rlc3Quc3VwYWJhc2UuY28nKSkge1xyXG4gICAgICBjb25zb2xlLmxvZygn4pqg77iPICBObyByZWFsIGRhdGFiYXNlIGNyZWRlbnRpYWxzIC0gc2tpcHBpbmcgc2NoZW1hIGV4dHJhY3Rpb24nKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIFxyXG4gICAgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoXHJcbiAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCEsXHJcbiAgICAgIHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkhXHJcbiAgICApXHJcbiAgfSlcclxuXHJcbiAgdGVzdCgnZXh0cmFjdCBjb21wbGV0ZSBkYXRhYmFzZSBzY2hlbWEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIXN1cGFiYXNlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdTa2lwcGluZyAtIG5vIGRhdGFiYXNlIGNvbm5lY3Rpb24nKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZygnXFxu8J+UjSBFWFRSQUNUSU5HIERBVEFCQVNFIFNDSEVNQS4uLlxcbicpXHJcblxyXG4gICAgLy8gR2V0IGFsbCB0YWJsZXNcclxuICAgIGNvbnN0IHsgZGF0YTogdGFibGVzLCBlcnJvcjogdGFibGVzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygnZ2V0X3RhYmxlX2luZm8nKVxyXG4gICAgXHJcbiAgICBpZiAodGFibGVzRXJyb3IpIHtcclxuICAgICAgLy8gRmFsbGJhY2sgdG8gbWFudWFsIHF1ZXJ5XHJcbiAgICAgIGNvbnN0IHsgZGF0YTogdGFibGVzRGF0YSwgZXJyb3I6IGZhbGxiYWNrRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2luZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMnKVxyXG4gICAgICAgIC5zZWxlY3QoJ3RhYmxlX25hbWUnKVxyXG4gICAgICAgIC5lcSgndGFibGVfc2NoZW1hJywgJ3B1YmxpYycpXHJcbiAgICAgICAgLmVxKCd0YWJsZV90eXBlJywgJ0JBU0UgVEFCTEUnKVxyXG5cclxuICAgICAgaWYgKGZhbGxiYWNrRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygn4p2MIENvdWxkIG5vdCBnZXQgdGFibGUgbGlzdDonLCBmYWxsYmFja0Vycm9yLm1lc3NhZ2UpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEV4dHJhY3Qgc2NoZW1hIGZvciBlYWNoIHRhYmxlIG1hbnVhbGx5XHJcbiAgICAgIGZvciAoY29uc3QgdGFibGUgb2YgdGFibGVzRGF0YSB8fCBbXSkge1xyXG4gICAgICAgIGF3YWl0IGV4dHJhY3RUYWJsZVNjaGVtYShzdXBhYmFzZSwgdGFibGUudGFibGVfbmFtZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpIC8vIFRlc3QgYWx3YXlzIHBhc3Nlcywgd2UganVzdCB3YW50IHRoZSBvdXRwdXRcclxuICB9KVxyXG59KVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFRhYmxlU2NoZW1hKHN1cGFiYXNlOiBhbnksIHRhYmxlTmFtZTogc3RyaW5nKSB7XHJcbiAgY29uc29sZS5sb2coYFxcbvCfk4ogVEFCTEU6ICR7dGFibGVOYW1lLnRvVXBwZXJDYXNlKCl9YClcclxuICBjb25zb2xlLmxvZygnPScgKyAnPScucmVwZWF0KHRhYmxlTmFtZS5sZW5ndGggKyA4KSlcclxuXHJcbiAgLy8gR2V0IGNvbHVtbnNcclxuICBjb25zdCB7IGRhdGE6IGNvbHVtbnMsIGVycm9yOiBjb2x1bW5zRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygnZ2V0X3RhYmxlX2NvbHVtbnMnLCB7XHJcbiAgICB0YWJsZV9uYW1lX2lucHV0OiB0YWJsZU5hbWVcclxuICB9KVxyXG5cclxuICBpZiAoY29sdW1uc0Vycm9yKSB7XHJcbiAgICAvLyBGYWxsYmFjayB0byBpbmZvcm1hdGlvbl9zY2hlbWEgcXVlcnlcclxuICAgIGNvbnN0IHF1ZXJ5ID0gYFxyXG4gICAgICBTRUxFQ1QgXHJcbiAgICAgICAgY29sdW1uX25hbWUsXHJcbiAgICAgICAgZGF0YV90eXBlLFxyXG4gICAgICAgIGlzX251bGxhYmxlLFxyXG4gICAgICAgIGNvbHVtbl9kZWZhdWx0LFxyXG4gICAgICAgIGNoYXJhY3Rlcl9tYXhpbXVtX2xlbmd0aCxcclxuICAgICAgICBudW1lcmljX3ByZWNpc2lvbixcclxuICAgICAgICBudW1lcmljX3NjYWxlXHJcbiAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLmNvbHVtbnMgXHJcbiAgICAgIFdIRVJFIHRhYmxlX3NjaGVtYSA9ICdwdWJsaWMnIFxyXG4gICAgICAgIEFORCB0YWJsZV9uYW1lID0gJyR7dGFibGVOYW1lfSdcclxuICAgICAgT1JERVIgQlkgb3JkaW5hbF9wb3NpdGlvblxyXG4gICAgYFxyXG4gICAgXHJcbiAgICBjb25zdCB7IGRhdGE6IGZhbGxiYWNrQ29sdW1ucywgZXJyb3I6IGZhbGxiYWNrRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygnZXhlY19zcWwnLCB7XHJcbiAgICAgIHNxbDogcXVlcnlcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKGZhbGxiYWNrRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5sb2coYOKdjCBDb3VsZCBub3QgZ2V0IGNvbHVtbnMgZm9yICR7dGFibGVOYW1lfTpgLCBmYWxsYmFja0Vycm9yLm1lc3NhZ2UpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc3BsYXkgY29sdW1uc1xyXG4gICAgaWYgKGZhbGxiYWNrQ29sdW1ucyAmJiBmYWxsYmFja0NvbHVtbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICBmYWxsYmFja0NvbHVtbnMuZm9yRWFjaCgoY29sOiBhbnkpID0+IHtcclxuICAgICAgICBjb25zdCBudWxsYWJsZSA9IGNvbC5pc19udWxsYWJsZSA9PT0gJ1lFUycgPyAnTlVMTCcgOiAnTk9UIE5VTEwnXHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbCA9IGNvbC5jb2x1bW5fZGVmYXVsdCA/IGAgREVGQVVMVCAke2NvbC5jb2x1bW5fZGVmYXVsdH1gIDogJydcclxuICAgICAgICBjb25zb2xlLmxvZyhgICAke2NvbC5jb2x1bW5fbmFtZS5wYWRFbmQoMjUpfSAke2NvbC5kYXRhX3R5cGUucGFkRW5kKDE1KX0gJHtudWxsYWJsZX0ke2RlZmF1bHRWYWx9YClcclxuICAgICAgfSlcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gVXNlIFJQQyByZXN1bHRcclxuICAgIGNvbnNvbGUubG9nKCdDb2x1bW5zOicsIGNvbHVtbnMpXHJcbiAgfVxyXG5cclxuICAvLyBHZXQgY29uc3RyYWludHMgKFBLcywgRktzLCBldGMuKVxyXG4gIGF3YWl0IGdldFRhYmxlQ29uc3RyYWludHMoc3VwYWJhc2UsIHRhYmxlTmFtZSlcclxuXHJcbiAgLy8gR2V0IGluZGV4ZXNcclxuICBhd2FpdCBnZXRUYWJsZUluZGV4ZXMoc3VwYWJhc2UsIHRhYmxlTmFtZSlcclxuXHJcbiAgLy8gR2V0IHNhbXBsZSBkYXRhIGNvdW50XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKHRhYmxlTmFtZSlcclxuICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYPCfk4ggUmVjb3JkIGNvdW50OiAke2NvdW50IHx8IDB9YClcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+TiCBSZWNvcmQgY291bnQ6IFVuYWJsZSB0byBxdWVyeScpXHJcbiAgfVxyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZXRUYWJsZUNvbnN0cmFpbnRzKHN1cGFiYXNlOiBhbnksIHRhYmxlTmFtZTogc3RyaW5nKSB7XHJcbiAgY29uc3QgY29uc3RyYWludHNRdWVyeSA9IGBcclxuICAgIFNFTEVDVCBcclxuICAgICAgdGMuY29uc3RyYWludF9uYW1lLFxyXG4gICAgICB0Yy5jb25zdHJhaW50X3R5cGUsXHJcbiAgICAgIGt1LmNvbHVtbl9uYW1lLFxyXG4gICAgICBjY3UudGFibGVfbmFtZSBBUyBmb3JlaWduX3RhYmxlX25hbWUsXHJcbiAgICAgIGNjdS5jb2x1bW5fbmFtZSBBUyBmb3JlaWduX2NvbHVtbl9uYW1lXHJcbiAgICBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZV9jb25zdHJhaW50cyB0Y1xyXG4gICAgTEVGVCBKT0lOIGluZm9ybWF0aW9uX3NjaGVtYS5rZXlfY29sdW1uX3VzYWdlIGt1IFxyXG4gICAgICBPTiB0Yy5jb25zdHJhaW50X25hbWUgPSBrdS5jb25zdHJhaW50X25hbWVcclxuICAgIExFRlQgSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEuY29uc3RyYWludF9jb2x1bW5fdXNhZ2UgY2N1IFxyXG4gICAgICBPTiB0Yy5jb25zdHJhaW50X25hbWUgPSBjY3UuY29uc3RyYWludF9uYW1lXHJcbiAgICBXSEVSRSB0Yy50YWJsZV9zY2hlbWEgPSAncHVibGljJyBcclxuICAgICAgQU5EIHRjLnRhYmxlX25hbWUgPSAnJHt0YWJsZU5hbWV9J1xyXG4gICAgT1JERVIgQlkgdGMuY29uc3RyYWludF90eXBlLCBrdS5jb2x1bW5fbmFtZVxyXG4gIGBcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgZGF0YTogY29uc3RyYWludHMgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygnZXhlY19zcWwnLCB7IHNxbDogY29uc3RyYWludHNRdWVyeSB9KVxyXG4gICAgXHJcbiAgICBpZiAoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnXFxu8J+UlyBDb25zdHJhaW50czonKVxyXG4gICAgICBjb25zdHJhaW50cy5mb3JFYWNoKChjb25zdHJhaW50OiBhbnkpID0+IHtcclxuICAgICAgICBpZiAoY29uc3RyYWludC5jb25zdHJhaW50X3R5cGUgPT09ICdQUklNQVJZIEtFWScpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGAgIPCflJEgUFJJTUFSWSBLRVk6ICR7Y29uc3RyYWludC5jb2x1bW5fbmFtZX1gKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc3RyYWludC5jb25zdHJhaW50X3R5cGUgPT09ICdGT1JFSUdOIEtFWScpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGAgIPCflJcgRk9SRUlHTiBLRVk6ICR7Y29uc3RyYWludC5jb2x1bW5fbmFtZX0g4oaSICR7Y29uc3RyYWludC5mb3JlaWduX3RhYmxlX25hbWV9KCR7Y29uc3RyYWludC5mb3JlaWduX2NvbHVtbl9uYW1lfSlgKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc3RyYWludC5jb25zdHJhaW50X3R5cGUgPT09ICdVTklRVUUnKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgICDirZAgVU5JUVVFOiAke2NvbnN0cmFpbnQuY29sdW1uX25hbWV9YClcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBnZXQgY29uc3RyYWludHMnKVxyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0VGFibGVJbmRleGVzKHN1cGFiYXNlOiBhbnksIHRhYmxlTmFtZTogc3RyaW5nKSB7XHJcbiAgY29uc3QgaW5kZXhRdWVyeSA9IGBcclxuICAgIFNFTEVDVCBcclxuICAgICAgaW5kZXhuYW1lLFxyXG4gICAgICBpbmRleGRlZlxyXG4gICAgRlJPTSBwZ19pbmRleGVzIFxyXG4gICAgV0hFUkUgc2NoZW1hbmFtZSA9ICdwdWJsaWMnIFxyXG4gICAgICBBTkQgdGFibGVuYW1lID0gJyR7dGFibGVOYW1lfSdcclxuICAgICAgQU5EIGluZGV4bmFtZSBOT1QgTElLRSAnJXBrZXknXHJcbiAgYFxyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBkYXRhOiBpbmRleGVzIH0gPSBhd2FpdCBzdXBhYmFzZS5ycGMoJ2V4ZWNfc3FsJywgeyBzcWw6IGluZGV4UXVlcnkgfSlcclxuICAgIFxyXG4gICAgaWYgKGluZGV4ZXMgJiYgaW5kZXhlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdcXG7wn5OKIEluZGV4ZXM6JylcclxuICAgICAgaW5kZXhlcy5mb3JFYWNoKChpbmRleDogYW55KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCAg8J+TiiAke2luZGV4LmluZGV4bmFtZX06ICR7aW5kZXguaW5kZXhkZWZ9YClcclxuICAgICAgfSlcclxuICAgIH1cclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLmxvZygnQ291bGQgbm90IGdldCBpbmRleGVzJylcclxuICB9XHJcbn1cclxuXHJcbi8vIFV0aWxpdHkgZnVuY3Rpb24geW91IGNhbiBjYWxsIGZyb20gYW55d2hlcmVcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlU2NoZW1hUmVwb3J0KCkge1xyXG4gIGlmICghcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIHx8IFxyXG4gICAgICAhcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSB8fFxyXG4gICAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwuaW5jbHVkZXMoJ3Rlc3Quc3VwYWJhc2UuY28nKSkge1xyXG4gICAgY29uc29sZS5sb2coJ+KaoO+4jyAgTm8gcmVhbCBkYXRhYmFzZSBjcmVkZW50aWFscyBhdmFpbGFibGUnKVxyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcblxyXG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KFxyXG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMISxcclxuICAgIHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkhXHJcbiAgKVxyXG5cclxuICAvLyBHZXQgc2ltcGxpZmllZCBzY2hlbWEgaW5mb1xyXG4gIGNvbnN0IHNjaGVtYToge1xyXG4gICAgdGFibGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG4gICAgcmVsYXRpb25zaGlwczogYW55W107XHJcbiAgICBzdW1tYXJ5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG4gIH0gPSB7XHJcbiAgICB0YWJsZXM6IHt9LFxyXG4gICAgcmVsYXRpb25zaGlwczogW10sXHJcbiAgICBzdW1tYXJ5OiB7fVxyXG4gIH1cclxuXHJcbiAgY29uc3QgdGFibGVzID0gW1xyXG4gICAgJ2FjdGl2aXRpZXMnLCAnc3RyYXZhX3Rva2VucycsICdzeW5jX3N0YXRlJywgXHJcbiAgICAnZ29hbF90eXBlcycsICd1c2VyX2dvYWxzJywgJ2dvYWxfcHJvZ3Jlc3MnLCAndXNlcl9vbmJvYXJkaW5nJ1xyXG4gIF1cclxuXHJcbiAgZm9yIChjb25zdCB0YWJsZU5hbWUgb2YgdGFibGVzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKHRhYmxlTmFtZSlcclxuICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxyXG4gICAgICBcclxuICAgICAgc2NoZW1hLnRhYmxlc1t0YWJsZU5hbWVdID0ge1xyXG4gICAgICAgIGV4aXN0czogdHJ1ZSxcclxuICAgICAgICByZWNvcmRDb3VudDogY291bnQgfHwgMFxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBzY2hlbWEudGFibGVzW3RhYmxlTmFtZV0gPSB7XHJcbiAgICAgICAgZXhpc3RzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcidcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc29sZS5sb2coJ1xcbvCfk4sgU0NIRU1BIFNVTU1BUlknKVxyXG4gIGNvbnNvbGUubG9nKCc9PT09PT09PT09PT09PT09JylcclxuICBPYmplY3QuZW50cmllcyhzY2hlbWEudGFibGVzKS5mb3JFYWNoKChbdGFibGUsIGluZm9dOiBbc3RyaW5nLCBhbnldKSA9PiB7XHJcbiAgICBjb25zdCBzdGF0dXMgPSBpbmZvLmV4aXN0cyA/ICfinIUnIDogJ+KdjCdcclxuICAgIGNvbnN0IGNvdW50ID0gaW5mby5leGlzdHMgPyBgKCR7aW5mby5yZWNvcmRDb3VudH0gcmVjb3JkcylgIDogYCgke2luZm8uZXJyb3J9KWBcclxuICAgIGNvbnNvbGUubG9nKGAke3N0YXR1c30gJHt0YWJsZS5wYWRFbmQoMjApfSAke2NvdW50fWApXHJcbiAgfSlcclxuXHJcbiAgcmV0dXJuIHNjaGVtYVxyXG59ICJdLCJuYW1lcyI6WyJnZW5lcmF0ZVNjaGVtYVJlcG9ydCIsImRlc2NyaWJlIiwic3VwYWJhc2UiLCJiZWZvcmVBbGwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsImluY2x1ZGVzIiwiY29uc29sZSIsImxvZyIsImNyZWF0ZUNsaWVudCIsInRlc3QiLCJkYXRhIiwidGFibGVzIiwiZXJyb3IiLCJ0YWJsZXNFcnJvciIsInJwYyIsInRhYmxlc0RhdGEiLCJmYWxsYmFja0Vycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwibWVzc2FnZSIsInRhYmxlIiwiZXh0cmFjdFRhYmxlU2NoZW1hIiwidGFibGVfbmFtZSIsImV4cGVjdCIsInRvQmUiLCJ0YWJsZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsInJlcGVhdCIsImxlbmd0aCIsImNvbHVtbnMiLCJjb2x1bW5zRXJyb3IiLCJ0YWJsZV9uYW1lX2lucHV0IiwicXVlcnkiLCJmYWxsYmFja0NvbHVtbnMiLCJzcWwiLCJmb3JFYWNoIiwiY29sIiwibnVsbGFibGUiLCJpc19udWxsYWJsZSIsImRlZmF1bHRWYWwiLCJjb2x1bW5fZGVmYXVsdCIsImNvbHVtbl9uYW1lIiwicGFkRW5kIiwiZGF0YV90eXBlIiwiZ2V0VGFibGVDb25zdHJhaW50cyIsImdldFRhYmxlSW5kZXhlcyIsImNvdW50IiwiaGVhZCIsImUiLCJjb25zdHJhaW50c1F1ZXJ5IiwiY29uc3RyYWludHMiLCJjb25zdHJhaW50IiwiY29uc3RyYWludF90eXBlIiwiZm9yZWlnbl90YWJsZV9uYW1lIiwiZm9yZWlnbl9jb2x1bW5fbmFtZSIsImluZGV4UXVlcnkiLCJpbmRleGVzIiwiaW5kZXgiLCJpbmRleG5hbWUiLCJpbmRleGRlZiIsInNjaGVtYSIsInJlbGF0aW9uc2hpcHMiLCJzdW1tYXJ5IiwiZXhpc3RzIiwicmVjb3JkQ291bnQiLCJFcnJvciIsIk9iamVjdCIsImVudHJpZXMiLCJpbmZvIiwic3RhdHVzIl0sIm1hcHBpbmdzIjoiOzs7OytCQXVMc0JBOzs7ZUFBQUE7Ozs0QkF2TE87QUFFN0JDLFNBQVMsb0JBQW9CO0lBQzNCLElBQUlDO0lBRUpDLFVBQVU7UUFDUixJQUFJLENBQUNDLFFBQVFDLEdBQUcsQ0FBQ0Msd0JBQXdCLElBQ3JDLENBQUNGLFFBQVFDLEdBQUcsQ0FBQ0UseUJBQXlCLElBQ3RDSCxRQUFRQyxHQUFHLENBQUNDLHdCQUF3QixDQUFDRSxRQUFRLENBQUMscUJBQXFCO1lBQ3JFQyxRQUFRQyxHQUFHLENBQUM7WUFDWjtRQUNGO1FBRUFSLFdBQVdTLElBQUFBLHdCQUFZLEVBQ3JCUCxRQUFRQyxHQUFHLENBQUNDLHdCQUF3QixFQUNwQ0YsUUFBUUMsR0FBRyxDQUFDRSx5QkFBeUI7SUFFekM7SUFFQUssS0FBSyxvQ0FBb0M7UUFDdkMsSUFBSSxDQUFDVixVQUFVO1lBQ2JPLFFBQVFDLEdBQUcsQ0FBQztZQUNaO1FBQ0Y7UUFFQUQsUUFBUUMsR0FBRyxDQUFDO1FBRVosaUJBQWlCO1FBQ2pCLE1BQU0sRUFBRUcsTUFBTUMsTUFBTSxFQUFFQyxPQUFPQyxXQUFXLEVBQUUsR0FBRyxNQUFNZCxTQUFTZSxHQUFHLENBQUM7UUFFaEUsSUFBSUQsYUFBYTtZQUNmLDJCQUEyQjtZQUMzQixNQUFNLEVBQUVILE1BQU1LLFVBQVUsRUFBRUgsT0FBT0ksYUFBYSxFQUFFLEdBQUcsTUFBTWpCLFNBQ3REa0IsSUFBSSxDQUFDLDZCQUNMQyxNQUFNLENBQUMsY0FDUEMsRUFBRSxDQUFDLGdCQUFnQixVQUNuQkEsRUFBRSxDQUFDLGNBQWM7WUFFcEIsSUFBSUgsZUFBZTtnQkFDakJWLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0JTLGNBQWNJLE9BQU87Z0JBQ2hFO1lBQ0Y7WUFFQSx5Q0FBeUM7WUFDekMsS0FBSyxNQUFNQyxTQUFTTixjQUFjLEVBQUUsQ0FBRTtnQkFDcEMsTUFBTU8sbUJBQW1CdkIsVUFBVXNCLE1BQU1FLFVBQVU7WUFDckQ7UUFDRjtRQUVBQyxPQUFPLE1BQU1DLElBQUksQ0FBQyxNQUFNLDhDQUE4Qzs7SUFDeEU7QUFDRjtBQUVBLGVBQWVILG1CQUFtQnZCLFFBQWEsRUFBRTJCLFNBQWlCO0lBQ2hFcEIsUUFBUUMsR0FBRyxDQUFDLENBQUMsWUFBWSxFQUFFbUIsVUFBVUMsV0FBVyxJQUFJO0lBQ3BEckIsUUFBUUMsR0FBRyxDQUFDLE1BQU0sSUFBSXFCLE1BQU0sQ0FBQ0YsVUFBVUcsTUFBTSxHQUFHO0lBRWhELGNBQWM7SUFDZCxNQUFNLEVBQUVuQixNQUFNb0IsT0FBTyxFQUFFbEIsT0FBT21CLFlBQVksRUFBRSxHQUFHLE1BQU1oQyxTQUFTZSxHQUFHLENBQUMscUJBQXFCO1FBQ3JGa0Isa0JBQWtCTjtJQUNwQjtJQUVBLElBQUlLLGNBQWM7UUFDaEIsdUNBQXVDO1FBQ3ZDLE1BQU1FLFFBQVEsQ0FBQzs7Ozs7Ozs7Ozs7MEJBV08sRUFBRVAsVUFBVTs7SUFFbEMsQ0FBQztRQUVELE1BQU0sRUFBRWhCLE1BQU13QixlQUFlLEVBQUV0QixPQUFPSSxhQUFhLEVBQUUsR0FBRyxNQUFNakIsU0FBU2UsR0FBRyxDQUFDLFlBQVk7WUFDckZxQixLQUFLRjtRQUNQO1FBRUEsSUFBSWpCLGVBQWU7WUFDakJWLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDRCQUE0QixFQUFFbUIsVUFBVSxDQUFDLENBQUMsRUFBRVYsY0FBY0ksT0FBTztZQUM5RTtRQUNGO1FBRUEsa0JBQWtCO1FBQ2xCLElBQUljLG1CQUFtQkEsZ0JBQWdCTCxNQUFNLEdBQUcsR0FBRztZQUNqREssZ0JBQWdCRSxPQUFPLENBQUMsQ0FBQ0M7Z0JBQ3ZCLE1BQU1DLFdBQVdELElBQUlFLFdBQVcsS0FBSyxRQUFRLFNBQVM7Z0JBQ3RELE1BQU1DLGFBQWFILElBQUlJLGNBQWMsR0FBRyxDQUFDLFNBQVMsRUFBRUosSUFBSUksY0FBYyxFQUFFLEdBQUc7Z0JBQzNFbkMsUUFBUUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFOEIsSUFBSUssV0FBVyxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUVOLElBQUlPLFNBQVMsQ0FBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFTCxXQUFXRSxZQUFZO1lBQ3BHO1FBQ0Y7SUFDRixPQUFPO1FBQ0wsaUJBQWlCO1FBQ2pCbEMsUUFBUUMsR0FBRyxDQUFDLFlBQVl1QjtJQUMxQjtJQUVBLG1DQUFtQztJQUNuQyxNQUFNZSxvQkFBb0I5QyxVQUFVMkI7SUFFcEMsY0FBYztJQUNkLE1BQU1vQixnQkFBZ0IvQyxVQUFVMkI7SUFFaEMsd0JBQXdCO0lBQ3hCLElBQUk7UUFDRixNQUFNLEVBQUVxQixLQUFLLEVBQUUsR0FBRyxNQUFNaEQsU0FDckJrQixJQUFJLENBQUNTLFdBQ0xSLE1BQU0sQ0FBQyxLQUFLO1lBQUU2QixPQUFPO1lBQVNDLE1BQU07UUFBSztRQUU1QzFDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixFQUFFd0MsU0FBUyxHQUFHO0lBQzlDLEVBQUUsT0FBT0UsR0FBRztRQUNWM0MsUUFBUUMsR0FBRyxDQUFDO0lBQ2Q7QUFDRjtBQUVBLGVBQWVzQyxvQkFBb0I5QyxRQUFhLEVBQUUyQixTQUFpQjtJQUNqRSxNQUFNd0IsbUJBQW1CLENBQUM7Ozs7Ozs7Ozs7Ozs7MkJBYUQsRUFBRXhCLFVBQVU7O0VBRXJDLENBQUM7SUFFRCxJQUFJO1FBQ0YsTUFBTSxFQUFFaEIsTUFBTXlDLFdBQVcsRUFBRSxHQUFHLE1BQU1wRCxTQUFTZSxHQUFHLENBQUMsWUFBWTtZQUFFcUIsS0FBS2U7UUFBaUI7UUFFckYsSUFBSUMsZUFBZUEsWUFBWXRCLE1BQU0sR0FBRyxHQUFHO1lBQ3pDdkIsUUFBUUMsR0FBRyxDQUFDO1lBQ1o0QyxZQUFZZixPQUFPLENBQUMsQ0FBQ2dCO2dCQUNuQixJQUFJQSxXQUFXQyxlQUFlLEtBQUssZUFBZTtvQkFDaEQvQyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxrQkFBa0IsRUFBRTZDLFdBQVdWLFdBQVcsRUFBRTtnQkFDM0QsT0FBTyxJQUFJVSxXQUFXQyxlQUFlLEtBQUssZUFBZTtvQkFDdkQvQyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxrQkFBa0IsRUFBRTZDLFdBQVdWLFdBQVcsQ0FBQyxHQUFHLEVBQUVVLFdBQVdFLGtCQUFrQixDQUFDLENBQUMsRUFBRUYsV0FBV0csbUJBQW1CLENBQUMsQ0FBQyxDQUFDO2dCQUNqSSxPQUFPLElBQUlILFdBQVdDLGVBQWUsS0FBSyxVQUFVO29CQUNsRC9DLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksRUFBRTZDLFdBQVdWLFdBQVcsRUFBRTtnQkFDckQ7WUFDRjtRQUNGO0lBQ0YsRUFBRSxPQUFPTyxHQUFHO1FBQ1YzQyxRQUFRQyxHQUFHLENBQUM7SUFDZDtBQUNGO0FBRUEsZUFBZXVDLGdCQUFnQi9DLFFBQWEsRUFBRTJCLFNBQWlCO0lBQzdELE1BQU04QixhQUFhLENBQUM7Ozs7Ozt1QkFNQyxFQUFFOUIsVUFBVTs7RUFFakMsQ0FBQztJQUVELElBQUk7UUFDRixNQUFNLEVBQUVoQixNQUFNK0MsT0FBTyxFQUFFLEdBQUcsTUFBTTFELFNBQVNlLEdBQUcsQ0FBQyxZQUFZO1lBQUVxQixLQUFLcUI7UUFBVztRQUUzRSxJQUFJQyxXQUFXQSxRQUFRNUIsTUFBTSxHQUFHLEdBQUc7WUFDakN2QixRQUFRQyxHQUFHLENBQUM7WUFDWmtELFFBQVFyQixPQUFPLENBQUMsQ0FBQ3NCO2dCQUNmcEQsUUFBUUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFbUQsTUFBTUMsU0FBUyxDQUFDLEVBQUUsRUFBRUQsTUFBTUUsUUFBUSxFQUFFO1lBQzFEO1FBQ0Y7SUFDRixFQUFFLE9BQU9YLEdBQUc7UUFDVjNDLFFBQVFDLEdBQUcsQ0FBQztJQUNkO0FBQ0Y7QUFHTyxlQUFlVjtJQUNwQixJQUFJLENBQUNJLFFBQVFDLEdBQUcsQ0FBQ0Msd0JBQXdCLElBQ3JDLENBQUNGLFFBQVFDLEdBQUcsQ0FBQ0UseUJBQXlCLElBQ3RDSCxRQUFRQyxHQUFHLENBQUNDLHdCQUF3QixDQUFDRSxRQUFRLENBQUMscUJBQXFCO1FBQ3JFQyxRQUFRQyxHQUFHLENBQUM7UUFDWixPQUFPO0lBQ1Q7SUFFQSxNQUFNUixXQUFXUyxJQUFBQSx3QkFBWSxFQUMzQlAsUUFBUUMsR0FBRyxDQUFDQyx3QkFBd0IsRUFDcENGLFFBQVFDLEdBQUcsQ0FBQ0UseUJBQXlCO0lBR3ZDLDZCQUE2QjtJQUM3QixNQUFNeUQsU0FJRjtRQUNGbEQsUUFBUSxDQUFDO1FBQ1RtRCxlQUFlLEVBQUU7UUFDakJDLFNBQVMsQ0FBQztJQUNaO0lBRUEsTUFBTXBELFNBQVM7UUFDYjtRQUFjO1FBQWlCO1FBQy9CO1FBQWM7UUFBYztRQUFpQjtLQUM5QztJQUVELEtBQUssTUFBTWUsYUFBYWYsT0FBUTtRQUM5QixJQUFJO1lBQ0YsTUFBTSxFQUFFb0MsS0FBSyxFQUFFLEdBQUcsTUFBTWhELFNBQ3JCa0IsSUFBSSxDQUFDUyxXQUNMUixNQUFNLENBQUMsS0FBSztnQkFBRTZCLE9BQU87Z0JBQVNDLE1BQU07WUFBSztZQUU1Q2EsT0FBT2xELE1BQU0sQ0FBQ2UsVUFBVSxHQUFHO2dCQUN6QnNDLFFBQVE7Z0JBQ1JDLGFBQWFsQixTQUFTO1lBQ3hCO1FBQ0YsRUFBRSxPQUFPbkMsT0FBTztZQUNkaUQsT0FBT2xELE1BQU0sQ0FBQ2UsVUFBVSxHQUFHO2dCQUN6QnNDLFFBQVE7Z0JBQ1JwRCxPQUFPQSxpQkFBaUJzRCxRQUFRdEQsTUFBTVEsT0FBTyxHQUFHO1lBQ2xEO1FBQ0Y7SUFDRjtJQUVBZCxRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDO0lBQ1o0RCxPQUFPQyxPQUFPLENBQUNQLE9BQU9sRCxNQUFNLEVBQUV5QixPQUFPLENBQUMsQ0FBQyxDQUFDZixPQUFPZ0QsS0FBb0I7UUFDakUsTUFBTUMsU0FBU0QsS0FBS0wsTUFBTSxHQUFHLE1BQU07UUFDbkMsTUFBTWpCLFFBQVFzQixLQUFLTCxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUVLLEtBQUtKLFdBQVcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRUksS0FBS3pELEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDL0VOLFFBQVFDLEdBQUcsQ0FBQyxHQUFHK0QsT0FBTyxDQUFDLEVBQUVqRCxNQUFNc0IsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFSSxPQUFPO0lBQ3REO0lBRUEsT0FBT2M7QUFDVCJ9