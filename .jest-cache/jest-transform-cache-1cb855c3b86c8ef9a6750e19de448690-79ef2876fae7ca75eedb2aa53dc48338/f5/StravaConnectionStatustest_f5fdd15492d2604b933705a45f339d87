bb4e4c1346e736de1d03fb04a8e3d342
"use strict";
// Mock the hooks
jest.mock('next/navigation', ()=>({
        useSearchParams: jest.fn(),
        useRouter: jest.fn(()=>({
                replace: jest.fn()
            }))
    }));
jest.mock('@/providers/AuthProvider', ()=>({
        useAuth: jest.fn(()=>({
                user: {
                    id: 'test-user'
                }
            }))
    }));
jest.mock('@/hooks/strava/useStravaConnection', ()=>({
        useStravaConnection: jest.fn(()=>({
                connectionStatus: {
                    connected: false
                },
                isLoading: false,
                error: null,
                refreshStatus: jest.fn(),
                disconnect: jest.fn()
            })),
        STRAVA_CONNECTION_QUERY_KEY: 'strava-connection'
    }));
jest.mock('@/hooks/use-strava-sync', ()=>({
        useStravaSync: jest.fn(()=>({
                syncData: jest.fn(),
                isLoading: false,
                lastSyncResult: null,
                error: null
            }))
    }));
jest.mock('@/hooks/use-strava-auth', ()=>({
        useStravaAuth: jest.fn(()=>({
                mutate: jest.fn(),
                isPending: false
            }))
    }));
jest.mock('@/hooks/strava/useStravaToken', ()=>({
        useStravaToken: jest.fn(()=>({
                accessToken: null
            })),
        STRAVA_TOKEN_QUERY_KEY: 'strava-token'
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _navigation = require("next/navigation");
const _reactquery = require("@tanstack/react-query");
const _StravaConnectionStatus = require("../../../components/strava/StravaConnectionStatus");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const mockUseSearchParams = _navigation.useSearchParams;
describe('StravaConnectionStatus OAuth Callback', ()=>{
    let queryClient;
    beforeEach(()=>{
        queryClient = new _reactquery.QueryClient({
            defaultOptions: {
                queries: {
                    retry: false
                },
                mutations: {
                    retry: false
                }
            }
        });
        jest.clearAllMocks();
    });
    const renderWithQueryClient = (component)=>{
        return (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_reactquery.QueryClientProvider, {
            client: queryClient,
            children: component
        }));
    };
    it('should handle OAuth callback with authorization code', async ()=>{
        const mockExchangeToken = jest.fn();
        const mockRouter = {
            replace: jest.fn()
        };
        // Mock search params with OAuth code
        mockUseSearchParams.mockReturnValue({
            get: jest.fn((key)=>{
                if (key === 'code') return 'test-oauth-code';
                return null;
            })
        });
        // Mock the hooks
        require('@/hooks/use-strava-auth').useStravaAuth.mockReturnValue({
            mutate: mockExchangeToken,
            isPending: false
        });
        require('next/navigation').useRouter.mockReturnValue(mockRouter);
        renderWithQueryClient(/*#__PURE__*/ (0, _jsxruntime.jsx)(_StravaConnectionStatus.StravaConnectionStatus, {}));
        await (0, _react1.waitFor)(()=>{
            expect(mockExchangeToken).toHaveBeenCalledWith('test-oauth-code', expect.objectContaining({
                onSuccess: expect.any(Function),
                onError: expect.any(Function)
            }));
        });
        // Verify URL cleanup happens immediately
        expect(mockRouter.replace).toHaveBeenCalled();
    });
    it('should handle OAuth error from Strava', async ()=>{
        const mockRouter = {
            replace: jest.fn()
        };
        // Mock search params with OAuth error
        mockUseSearchParams.mockReturnValue({
            get: jest.fn((key)=>{
                if (key === 'error') return 'access_denied';
                if (key === 'error_description') return 'User denied access';
                return null;
            })
        });
        require('next/navigation').useRouter.mockReturnValue(mockRouter);
        renderWithQueryClient(/*#__PURE__*/ (0, _jsxruntime.jsx)(_StravaConnectionStatus.StravaConnectionStatus, {}));
        await (0, _react1.waitFor)(()=>{
            expect(_react1.screen.getByText(/User denied access/)).toBeInTheDocument();
        });
        // Verify URL cleanup
        expect(mockRouter.replace).toHaveBeenCalled();
    });
    it('should not process OAuth code when already connected', ()=>{
        const mockExchangeToken = jest.fn();
        // Mock search params with OAuth code
        mockUseSearchParams.mockReturnValue({
            get: jest.fn((key)=>{
                if (key === 'code') return 'test-oauth-code';
                return null;
            })
        });
        // Mock connection status as already connected
        require('@/hooks/strava/useStravaConnection').useStravaConnection.mockReturnValue({
            connectionStatus: {
                connected: true
            },
            isLoading: false,
            error: null,
            refreshStatus: jest.fn(),
            disconnect: jest.fn()
        });
        require('@/hooks/use-strava-auth').useStravaAuth.mockReturnValue({
            mutate: mockExchangeToken,
            isPending: false
        });
        renderWithQueryClient(/*#__PURE__*/ (0, _jsxruntime.jsx)(_StravaConnectionStatus.StravaConnectionStatus, {}));
        // Should not call exchangeToken when already connected
        expect(mockExchangeToken).not.toHaveBeenCalled();
    });
    it('should not process OAuth code when already in progress', ()=>{
        const mockExchangeToken = jest.fn();
        // Mock search params with OAuth code
        mockUseSearchParams.mockReturnValue({
            get: jest.fn((key)=>{
                if (key === 'code') return 'test-oauth-code';
                return null;
            })
        });
        // Mock auth as in progress
        require('@/hooks/use-strava-auth').useStravaAuth.mockReturnValue({
            mutate: mockExchangeToken,
            isPending: true
        });
        renderWithQueryClient(/*#__PURE__*/ (0, _jsxruntime.jsx)(_StravaConnectionStatus.StravaConnectionStatus, {}));
        // Should not call exchangeToken when already in progress
        expect(mockExchangeToken).not.toHaveBeenCalled();
    });
    it('should invalidate query cache on successful OAuth', async ()=>{
        const mockExchangeToken = jest.fn();
        const invalidateQueriesSpy = jest.spyOn(queryClient, 'invalidateQueries');
        // Mock search params with OAuth code
        mockUseSearchParams.mockReturnValue({
            get: jest.fn((key)=>{
                if (key === 'code') return 'test-oauth-code';
                return null;
            })
        });
        // Make sure connection status is not connected to allow OAuth processing
        require('@/hooks/strava/useStravaConnection').useStravaConnection.mockReturnValue({
            connectionStatus: {
                connected: false
            },
            isLoading: false,
            error: null,
            refreshStatus: jest.fn(),
            disconnect: jest.fn()
        });
        require('@/hooks/use-strava-auth').useStravaAuth.mockReturnValue({
            mutate: mockExchangeToken,
            isPending: false
        });
        renderWithQueryClient(/*#__PURE__*/ (0, _jsxruntime.jsx)(_StravaConnectionStatus.StravaConnectionStatus, {}));
        // Get the onSuccess callback that was passed to exchangeToken
        await (0, _react1.waitFor)(()=>{
            expect(mockExchangeToken).toHaveBeenCalled();
        });
        const onSuccessCallback = mockExchangeToken.mock.calls[0][1].onSuccess;
        // Simulate successful OAuth
        await onSuccessCallback({
            success: true,
            athlete: {
                id: 123
            }
        });
        // Verify cache invalidation
        expect(invalidateQueriesSpy).toHaveBeenCalledWith({
            queryKey: [
                'strava',
                'connection'
            ]
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdGlhbWFcXERlc2t0b3BcXENvZGluZ1xcZW5kdXJvcmV2YW1wXFxfX3Rlc3RzX19cXGNvbXBvbmVudHNcXHN0cmF2YVxcU3RyYXZhQ29ubmVjdGlvblN0YXR1cy50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyByZW5kZXIsIHNjcmVlbiwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VTZWFyY2hQYXJhbXMgfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xyXG5pbXBvcnQgeyBRdWVyeUNsaWVudCwgUXVlcnlDbGllbnRQcm92aWRlciB9IGZyb20gJ0B0YW5zdGFjay9yZWFjdC1xdWVyeSc7XHJcbmltcG9ydCB7IFN0cmF2YUNvbm5lY3Rpb25TdGF0dXMgfSBmcm9tICdAL2NvbXBvbmVudHMvc3RyYXZhL1N0cmF2YUNvbm5lY3Rpb25TdGF0dXMnO1xyXG5cclxuLy8gTW9jayB0aGUgaG9va3NcclxuamVzdC5tb2NrKCduZXh0L25hdmlnYXRpb24nLCAoKSA9PiAoe1xyXG4gIHVzZVNlYXJjaFBhcmFtczogamVzdC5mbigpLFxyXG4gIHVzZVJvdXRlcjogamVzdC5mbigoKSA9PiAoe1xyXG4gICAgcmVwbGFjZTogamVzdC5mbigpLFxyXG4gIH0pKSxcclxufSkpO1xyXG5cclxuamVzdC5tb2NrKCdAL3Byb3ZpZGVycy9BdXRoUHJvdmlkZXInLCAoKSA9PiAoe1xyXG4gIHVzZUF1dGg6IGplc3QuZm4oKCkgPT4gKHtcclxuICAgIHVzZXI6IHsgaWQ6ICd0ZXN0LXVzZXInIH1cclxuICB9KSksXHJcbn0pKTtcclxuXHJcbmplc3QubW9jaygnQC9ob29rcy9zdHJhdmEvdXNlU3RyYXZhQ29ubmVjdGlvbicsICgpID0+ICh7XHJcbiAgdXNlU3RyYXZhQ29ubmVjdGlvbjogamVzdC5mbigoKSA9PiAoe1xyXG4gICAgY29ubmVjdGlvblN0YXR1czogeyBjb25uZWN0ZWQ6IGZhbHNlIH0sXHJcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxyXG4gICAgZXJyb3I6IG51bGwsXHJcbiAgICByZWZyZXNoU3RhdHVzOiBqZXN0LmZuKCksXHJcbiAgICBkaXNjb25uZWN0OiBqZXN0LmZuKCksXHJcbiAgfSkpLFxyXG4gIFNUUkFWQV9DT05ORUNUSU9OX1FVRVJZX0tFWTogJ3N0cmF2YS1jb25uZWN0aW9uJyxcclxufSkpO1xyXG5cclxuamVzdC5tb2NrKCdAL2hvb2tzL3VzZS1zdHJhdmEtc3luYycsICgpID0+ICh7XHJcbiAgdXNlU3RyYXZhU3luYzogamVzdC5mbigoKSA9PiAoe1xyXG4gICAgc3luY0RhdGE6IGplc3QuZm4oKSxcclxuICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICBsYXN0U3luY1Jlc3VsdDogbnVsbCxcclxuICAgIGVycm9yOiBudWxsLFxyXG4gIH0pKSxcclxufSkpO1xyXG5cclxuamVzdC5tb2NrKCdAL2hvb2tzL3VzZS1zdHJhdmEtYXV0aCcsICgpID0+ICh7XHJcbiAgdXNlU3RyYXZhQXV0aDogamVzdC5mbigoKSA9PiAoe1xyXG4gICAgbXV0YXRlOiBqZXN0LmZuKCksXHJcbiAgICBpc1BlbmRpbmc6IGZhbHNlLFxyXG4gIH0pKSxcclxufSkpO1xyXG5cclxuamVzdC5tb2NrKCdAL2hvb2tzL3N0cmF2YS91c2VTdHJhdmFUb2tlbicsICgpID0+ICh7XHJcbiAgdXNlU3RyYXZhVG9rZW46IGplc3QuZm4oKCkgPT4gKHtcclxuICAgIGFjY2Vzc1Rva2VuOiBudWxsLFxyXG4gIH0pKSxcclxuICBTVFJBVkFfVE9LRU5fUVVFUllfS0VZOiAnc3RyYXZhLXRva2VuJyxcclxufSkpO1xyXG5cclxuY29uc3QgbW9ja1VzZVNlYXJjaFBhcmFtcyA9IHVzZVNlYXJjaFBhcmFtcyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiB1c2VTZWFyY2hQYXJhbXM+O1xyXG5cclxuZGVzY3JpYmUoJ1N0cmF2YUNvbm5lY3Rpb25TdGF0dXMgT0F1dGggQ2FsbGJhY2snLCAoKSA9PiB7XHJcbiAgbGV0IHF1ZXJ5Q2xpZW50OiBRdWVyeUNsaWVudDtcclxuXHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICBxdWVyeUNsaWVudCA9IG5ldyBRdWVyeUNsaWVudCh7XHJcbiAgICAgIGRlZmF1bHRPcHRpb25zOiB7XHJcbiAgICAgICAgcXVlcmllczogeyByZXRyeTogZmFsc2UgfSxcclxuICAgICAgICBtdXRhdGlvbnM6IHsgcmV0cnk6IGZhbHNlIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xyXG4gIH0pO1xyXG5cclxuICBjb25zdCByZW5kZXJXaXRoUXVlcnlDbGllbnQgPSAoY29tcG9uZW50OiBSZWFjdC5SZWFjdEVsZW1lbnQpID0+IHtcclxuICAgIHJldHVybiByZW5kZXIoXHJcbiAgICAgIDxRdWVyeUNsaWVudFByb3ZpZGVyIGNsaWVudD17cXVlcnlDbGllbnR9PlxyXG4gICAgICAgIHtjb21wb25lbnR9XHJcbiAgICAgIDwvUXVlcnlDbGllbnRQcm92aWRlcj5cclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgT0F1dGggY2FsbGJhY2sgd2l0aCBhdXRob3JpemF0aW9uIGNvZGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBtb2NrRXhjaGFuZ2VUb2tlbiA9IGplc3QuZm4oKTtcclxuICAgIGNvbnN0IG1vY2tSb3V0ZXIgPSB7IHJlcGxhY2U6IGplc3QuZm4oKSB9O1xyXG4gICAgXHJcbiAgICAvLyBNb2NrIHNlYXJjaCBwYXJhbXMgd2l0aCBPQXV0aCBjb2RlXHJcbiAgICBtb2NrVXNlU2VhcmNoUGFyYW1zLm1vY2tSZXR1cm5WYWx1ZSh7XHJcbiAgICAgIGdldDogamVzdC5mbigoa2V5OiBzdHJpbmcpID0+IHtcclxuICAgICAgICBpZiAoa2V5ID09PSAnY29kZScpIHJldHVybiAndGVzdC1vYXV0aC1jb2RlJztcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfSksXHJcbiAgICB9IGFzIGFueSk7XHJcblxyXG4gICAgLy8gTW9jayB0aGUgaG9va3NcclxuICAgIHJlcXVpcmUoJ0AvaG9va3MvdXNlLXN0cmF2YS1hdXRoJykudXNlU3RyYXZhQXV0aC5tb2NrUmV0dXJuVmFsdWUoe1xyXG4gICAgICBtdXRhdGU6IG1vY2tFeGNoYW5nZVRva2VuLFxyXG4gICAgICBpc1BlbmRpbmc6IGZhbHNlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmVxdWlyZSgnbmV4dC9uYXZpZ2F0aW9uJykudXNlUm91dGVyLm1vY2tSZXR1cm5WYWx1ZShtb2NrUm91dGVyKTtcclxuXHJcbiAgICByZW5kZXJXaXRoUXVlcnlDbGllbnQoPFN0cmF2YUNvbm5lY3Rpb25TdGF0dXMgLz4pO1xyXG5cclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QobW9ja0V4Y2hhbmdlVG9rZW4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAgICd0ZXN0LW9hdXRoLWNvZGUnLFxyXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICAgIG9uU3VjY2VzczogZXhwZWN0LmFueShGdW5jdGlvbiksXHJcbiAgICAgICAgICBvbkVycm9yOiBleHBlY3QuYW55KEZ1bmN0aW9uKSxcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVmVyaWZ5IFVSTCBjbGVhbnVwIGhhcHBlbnMgaW1tZWRpYXRlbHlcclxuICAgIGV4cGVjdChtb2NrUm91dGVyLnJlcGxhY2UpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgT0F1dGggZXJyb3IgZnJvbSBTdHJhdmEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBtb2NrUm91dGVyID0geyByZXBsYWNlOiBqZXN0LmZuKCkgfTtcclxuICAgIFxyXG4gICAgLy8gTW9jayBzZWFyY2ggcGFyYW1zIHdpdGggT0F1dGggZXJyb3JcclxuICAgIG1vY2tVc2VTZWFyY2hQYXJhbXMubW9ja1JldHVyblZhbHVlKHtcclxuICAgICAgZ2V0OiBqZXN0LmZuKChrZXk6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIGlmIChrZXkgPT09ICdlcnJvcicpIHJldHVybiAnYWNjZXNzX2RlbmllZCc7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2Vycm9yX2Rlc2NyaXB0aW9uJykgcmV0dXJuICdVc2VyIGRlbmllZCBhY2Nlc3MnO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9KSxcclxuICAgIH0gYXMgYW55KTtcclxuXHJcbiAgICByZXF1aXJlKCduZXh0L25hdmlnYXRpb24nKS51c2VSb3V0ZXIubW9ja1JldHVyblZhbHVlKG1vY2tSb3V0ZXIpO1xyXG5cclxuICAgIHJlbmRlcldpdGhRdWVyeUNsaWVudCg8U3RyYXZhQ29ubmVjdGlvblN0YXR1cyAvPik7XHJcblxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC9Vc2VyIGRlbmllZCBhY2Nlc3MvKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFZlcmlmeSBVUkwgY2xlYW51cFxyXG4gICAgZXhwZWN0KG1vY2tSb3V0ZXIucmVwbGFjZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnc2hvdWxkIG5vdCBwcm9jZXNzIE9BdXRoIGNvZGUgd2hlbiBhbHJlYWR5IGNvbm5lY3RlZCcsICgpID0+IHtcclxuICAgIGNvbnN0IG1vY2tFeGNoYW5nZVRva2VuID0gamVzdC5mbigpO1xyXG4gICAgXHJcbiAgICAvLyBNb2NrIHNlYXJjaCBwYXJhbXMgd2l0aCBPQXV0aCBjb2RlXHJcbiAgICBtb2NrVXNlU2VhcmNoUGFyYW1zLm1vY2tSZXR1cm5WYWx1ZSh7XHJcbiAgICAgIGdldDogamVzdC5mbigoa2V5OiBzdHJpbmcpID0+IHtcclxuICAgICAgICBpZiAoa2V5ID09PSAnY29kZScpIHJldHVybiAndGVzdC1vYXV0aC1jb2RlJztcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfSksXHJcbiAgICB9IGFzIGFueSk7XHJcblxyXG4gICAgLy8gTW9jayBjb25uZWN0aW9uIHN0YXR1cyBhcyBhbHJlYWR5IGNvbm5lY3RlZFxyXG4gICAgcmVxdWlyZSgnQC9ob29rcy9zdHJhdmEvdXNlU3RyYXZhQ29ubmVjdGlvbicpLnVzZVN0cmF2YUNvbm5lY3Rpb24ubW9ja1JldHVyblZhbHVlKHtcclxuICAgICAgY29ubmVjdGlvblN0YXR1czogeyBjb25uZWN0ZWQ6IHRydWUgfSxcclxuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICAgIHJlZnJlc2hTdGF0dXM6IGplc3QuZm4oKSxcclxuICAgICAgZGlzY29ubmVjdDogamVzdC5mbigpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmVxdWlyZSgnQC9ob29rcy91c2Utc3RyYXZhLWF1dGgnKS51c2VTdHJhdmFBdXRoLm1vY2tSZXR1cm5WYWx1ZSh7XHJcbiAgICAgIG11dGF0ZTogbW9ja0V4Y2hhbmdlVG9rZW4sXHJcbiAgICAgIGlzUGVuZGluZzogZmFsc2UsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZW5kZXJXaXRoUXVlcnlDbGllbnQoPFN0cmF2YUNvbm5lY3Rpb25TdGF0dXMgLz4pO1xyXG5cclxuICAgIC8vIFNob3VsZCBub3QgY2FsbCBleGNoYW5nZVRva2VuIHdoZW4gYWxyZWFkeSBjb25uZWN0ZWRcclxuICAgIGV4cGVjdChtb2NrRXhjaGFuZ2VUb2tlbikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3Nob3VsZCBub3QgcHJvY2VzcyBPQXV0aCBjb2RlIHdoZW4gYWxyZWFkeSBpbiBwcm9ncmVzcycsICgpID0+IHtcclxuICAgIGNvbnN0IG1vY2tFeGNoYW5nZVRva2VuID0gamVzdC5mbigpO1xyXG4gICAgXHJcbiAgICAvLyBNb2NrIHNlYXJjaCBwYXJhbXMgd2l0aCBPQXV0aCBjb2RlXHJcbiAgICBtb2NrVXNlU2VhcmNoUGFyYW1zLm1vY2tSZXR1cm5WYWx1ZSh7XHJcbiAgICAgIGdldDogamVzdC5mbigoa2V5OiBzdHJpbmcpID0+IHtcclxuICAgICAgICBpZiAoa2V5ID09PSAnY29kZScpIHJldHVybiAndGVzdC1vYXV0aC1jb2RlJztcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfSksXHJcbiAgICB9IGFzIGFueSk7XHJcblxyXG4gICAgLy8gTW9jayBhdXRoIGFzIGluIHByb2dyZXNzXHJcbiAgICByZXF1aXJlKCdAL2hvb2tzL3VzZS1zdHJhdmEtYXV0aCcpLnVzZVN0cmF2YUF1dGgubW9ja1JldHVyblZhbHVlKHtcclxuICAgICAgbXV0YXRlOiBtb2NrRXhjaGFuZ2VUb2tlbixcclxuICAgICAgaXNQZW5kaW5nOiB0cnVlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmVuZGVyV2l0aFF1ZXJ5Q2xpZW50KDxTdHJhdmFDb25uZWN0aW9uU3RhdHVzIC8+KTtcclxuXHJcbiAgICAvLyBTaG91bGQgbm90IGNhbGwgZXhjaGFuZ2VUb2tlbiB3aGVuIGFscmVhZHkgaW4gcHJvZ3Jlc3NcclxuICAgIGV4cGVjdChtb2NrRXhjaGFuZ2VUb2tlbikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3Nob3VsZCBpbnZhbGlkYXRlIHF1ZXJ5IGNhY2hlIG9uIHN1Y2Nlc3NmdWwgT0F1dGgnLCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBtb2NrRXhjaGFuZ2VUb2tlbiA9IGplc3QuZm4oKTtcclxuICAgIGNvbnN0IGludmFsaWRhdGVRdWVyaWVzU3B5ID0gamVzdC5zcHlPbihxdWVyeUNsaWVudCwgJ2ludmFsaWRhdGVRdWVyaWVzJyk7XHJcbiAgICBcclxuICAgIC8vIE1vY2sgc2VhcmNoIHBhcmFtcyB3aXRoIE9BdXRoIGNvZGVcclxuICAgIG1vY2tVc2VTZWFyY2hQYXJhbXMubW9ja1JldHVyblZhbHVlKHtcclxuICAgICAgZ2V0OiBqZXN0LmZuKChrZXk6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIGlmIChrZXkgPT09ICdjb2RlJykgcmV0dXJuICd0ZXN0LW9hdXRoLWNvZGUnO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9KSxcclxuICAgIH0gYXMgYW55KTtcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgY29ubmVjdGlvbiBzdGF0dXMgaXMgbm90IGNvbm5lY3RlZCB0byBhbGxvdyBPQXV0aCBwcm9jZXNzaW5nXHJcbiAgICByZXF1aXJlKCdAL2hvb2tzL3N0cmF2YS91c2VTdHJhdmFDb25uZWN0aW9uJykudXNlU3RyYXZhQ29ubmVjdGlvbi5tb2NrUmV0dXJuVmFsdWUoe1xyXG4gICAgICBjb25uZWN0aW9uU3RhdHVzOiB7IGNvbm5lY3RlZDogZmFsc2UgfSxcclxuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgZXJyb3I6IG51bGwsXHJcbiAgICAgIHJlZnJlc2hTdGF0dXM6IGplc3QuZm4oKSxcclxuICAgICAgZGlzY29ubmVjdDogamVzdC5mbigpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmVxdWlyZSgnQC9ob29rcy91c2Utc3RyYXZhLWF1dGgnKS51c2VTdHJhdmFBdXRoLm1vY2tSZXR1cm5WYWx1ZSh7XHJcbiAgICAgIG11dGF0ZTogbW9ja0V4Y2hhbmdlVG9rZW4sXHJcbiAgICAgIGlzUGVuZGluZzogZmFsc2UsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZW5kZXJXaXRoUXVlcnlDbGllbnQoPFN0cmF2YUNvbm5lY3Rpb25TdGF0dXMgLz4pO1xyXG5cclxuICAgIC8vIEdldCB0aGUgb25TdWNjZXNzIGNhbGxiYWNrIHRoYXQgd2FzIHBhc3NlZCB0byBleGNoYW5nZVRva2VuXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KG1vY2tFeGNoYW5nZVRva2VuKS50b0hhdmVCZWVuQ2FsbGVkKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBvblN1Y2Nlc3NDYWxsYmFjayA9IG1vY2tFeGNoYW5nZVRva2VuLm1vY2suY2FsbHNbMF1bMV0ub25TdWNjZXNzO1xyXG4gICAgXHJcbiAgICAvLyBTaW11bGF0ZSBzdWNjZXNzZnVsIE9BdXRoXHJcbiAgICBhd2FpdCBvblN1Y2Nlc3NDYWxsYmFjayh7IHN1Y2Nlc3M6IHRydWUsIGF0aGxldGU6IHsgaWQ6IDEyMyB9IH0pO1xyXG5cclxuICAgIC8vIFZlcmlmeSBjYWNoZSBpbnZhbGlkYXRpb25cclxuICAgIGV4cGVjdChpbnZhbGlkYXRlUXVlcmllc1NweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xyXG4gICAgICBxdWVyeUtleTogWydzdHJhdmEnLCAnY29ubmVjdGlvbiddLFxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pOyAiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJ1c2VTZWFyY2hQYXJhbXMiLCJmbiIsInVzZVJvdXRlciIsInJlcGxhY2UiLCJ1c2VBdXRoIiwidXNlciIsImlkIiwidXNlU3RyYXZhQ29ubmVjdGlvbiIsImNvbm5lY3Rpb25TdGF0dXMiLCJjb25uZWN0ZWQiLCJpc0xvYWRpbmciLCJlcnJvciIsInJlZnJlc2hTdGF0dXMiLCJkaXNjb25uZWN0IiwiU1RSQVZBX0NPTk5FQ1RJT05fUVVFUllfS0VZIiwidXNlU3RyYXZhU3luYyIsInN5bmNEYXRhIiwibGFzdFN5bmNSZXN1bHQiLCJ1c2VTdHJhdmFBdXRoIiwibXV0YXRlIiwiaXNQZW5kaW5nIiwidXNlU3RyYXZhVG9rZW4iLCJhY2Nlc3NUb2tlbiIsIlNUUkFWQV9UT0tFTl9RVUVSWV9LRVkiLCJtb2NrVXNlU2VhcmNoUGFyYW1zIiwiZGVzY3JpYmUiLCJxdWVyeUNsaWVudCIsImJlZm9yZUVhY2giLCJRdWVyeUNsaWVudCIsImRlZmF1bHRPcHRpb25zIiwicXVlcmllcyIsInJldHJ5IiwibXV0YXRpb25zIiwiY2xlYXJBbGxNb2NrcyIsInJlbmRlcldpdGhRdWVyeUNsaWVudCIsImNvbXBvbmVudCIsInJlbmRlciIsIlF1ZXJ5Q2xpZW50UHJvdmlkZXIiLCJjbGllbnQiLCJpdCIsIm1vY2tFeGNoYW5nZVRva2VuIiwibW9ja1JvdXRlciIsIm1vY2tSZXR1cm5WYWx1ZSIsImdldCIsImtleSIsInJlcXVpcmUiLCJTdHJhdmFDb25uZWN0aW9uU3RhdHVzIiwid2FpdEZvciIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwib2JqZWN0Q29udGFpbmluZyIsIm9uU3VjY2VzcyIsImFueSIsIkZ1bmN0aW9uIiwib25FcnJvciIsInRvSGF2ZUJlZW5DYWxsZWQiLCJzY3JlZW4iLCJnZXRCeVRleHQiLCJ0b0JlSW5UaGVEb2N1bWVudCIsIm5vdCIsImludmFsaWRhdGVRdWVyaWVzU3B5Iiwic3B5T24iLCJvblN1Y2Nlc3NDYWxsYmFjayIsImNhbGxzIiwic3VjY2VzcyIsImF0aGxldGUiLCJxdWVyeUtleSJdLCJtYXBwaW5ncyI6IjtBQU1BLGlCQUFpQjtBQUNqQkEsS0FBS0MsSUFBSSxDQUFDLG1CQUFtQixJQUFPLENBQUE7UUFDbENDLGlCQUFpQkYsS0FBS0csRUFBRTtRQUN4QkMsV0FBV0osS0FBS0csRUFBRSxDQUFDLElBQU8sQ0FBQTtnQkFDeEJFLFNBQVNMLEtBQUtHLEVBQUU7WUFDbEIsQ0FBQTtJQUNGLENBQUE7QUFFQUgsS0FBS0MsSUFBSSxDQUFDLDRCQUE0QixJQUFPLENBQUE7UUFDM0NLLFNBQVNOLEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7Z0JBQ3RCSSxNQUFNO29CQUFFQyxJQUFJO2dCQUFZO1lBQzFCLENBQUE7SUFDRixDQUFBO0FBRUFSLEtBQUtDLElBQUksQ0FBQyxzQ0FBc0MsSUFBTyxDQUFBO1FBQ3JEUSxxQkFBcUJULEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7Z0JBQ2xDTyxrQkFBa0I7b0JBQUVDLFdBQVc7Z0JBQU07Z0JBQ3JDQyxXQUFXO2dC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