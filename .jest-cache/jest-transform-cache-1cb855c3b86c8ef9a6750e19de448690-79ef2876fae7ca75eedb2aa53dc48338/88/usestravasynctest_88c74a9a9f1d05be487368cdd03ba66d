39c855f6a2d2fbf42470ec98b5db73f7
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = require("@testing-library/react");
const _reactquery = require("@tanstack/react-query");
const _usestravasync = require("../../hooks/use-strava-sync");
// Mock fetch globally
global.fetch = jest.fn();
const mockFetch = fetch;
// Create a wrapper for React Query
const createWrapper = ()=>{
    const queryClient = new _reactquery.QueryClient({
        defaultOptions: {
            queries: {
                retry: false
            },
            mutations: {
                retry: false
            }
        }
    });
    return ({ children })=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_reactquery.QueryClientProvider, {
            client: queryClient,
            children: children
        });
};
describe('useStravaSync', ()=>{
    beforeEach(()=>{
        mockFetch.mockClear();
    });
    afterEach(()=>{
        jest.clearAllMocks();
    });
    describe('sync status', ()=>{
        it('should fetch sync status successfully', async ()=>{
            const mockSyncStatus = {
                syncState: {
                    user_id: 'test-user',
                    sync_enabled: true,
                    sync_requests_today: 2,
                    last_activity_sync: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
                    consecutive_errors: 0,
                    last_error_message: null
                },
                activityCount: 150,
                canSync: true
            };
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockSyncStatus
            });
            const { result } = (0, _react.renderHook)(()=>(0, _usestravasync.useStravaSync)(), {
                wrapper: createWrapper()
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isLoadingStatus).toBe(false);
            }, {
                timeout: 5000
            });
            expect(result.current.syncStatus).toEqual(mockSyncStatus);
            expect(mockFetch).toHaveBeenCalledWith('/api/strava/sync');
        });
        it('should handle sync status error', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 500
            });
            const { result } = (0, _react.renderHook)(()=>(0, _usestravasync.useStravaSync)(), {
                wrapper: createWrapper()
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isLoadingStatus).toBe(false);
            }, {
                timeout: 5000
            });
            expect(result.current.statusError).toBeTruthy();
        });
    });
    describe('sync triggers', ()=>{
        beforeEach(()=>{
            // Mock successful sync status
            mockFetch.mockImplementation((url)=>{
                if (url === '/api/strava/sync' && typeof url === 'string') {
                    return Promise.resolve({
                        ok: true,
                        json: async ()=>({
                                syncState: {
                                    sync_enabled: true,
                                    sync_requests_today: 0
                                },
                                activityCount: 100,
                                canSync: true
                            })
                    });
                }
                return Promise.reject(new Error('Unknown URL'));
            });
        });
        it('should trigger latest sync with correct parameters', async ()=>{
            const mockSyncResult = {
                success: true,
                message: 'Sync completed successfully',
                data: {
                    activitiesProcessed: 15,
                    newActivities: 10,
                    updatedActivities: 5,
                    syncDuration: 2500
                }
            };
            mockFetch.mockImplementation((url, options)=>{
                if (url === '/api/strava/sync' && options?.method === 'POST') {
                    const body = JSON.parse(options.body);
                    expect(body).toEqual({
                        maxActivities: 50
                    });
                    return Promise.resolve({
                        ok: true,
                        json: async ()=>mockSyncResult
                    });
                }
                // Default to sync status response
                return Promise.resolve({
                    ok: true,
                    json: async ()=>({
                            syncState: {
                                sync_enabled: true
                            },
                            activityCount: 100,
                            canSync: true
                        })
                });
            });
            const { result } = (0, _react.renderHook)(()=>(0, _usestravasync.useStravaSync)(), {
                wrapper: createWrapper()
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isLoadingStatus).toBe(false);
            }, {
                timeout: 5000
            });
            // Trigger sync
            result.current.syncLatest();
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSyncing).toBe(false);
            });
            expect(result.current.syncResult).toEqual(mockSyncResult);
        });
        it('should trigger weekly sync with correct parameters', async ()=>{
            mockFetch.mockImplementation((url, options)=>{
                if (url === '/api/strava/sync' && options?.method === 'POST') {
                    const body = JSON.parse(options.body);
                    expect(body).toEqual({
                        sinceDays: 7,
                        maxActivities: 100
                    });
                    return Promise.resolve({
                        ok: true,
                        json: async ()=>({
                                success: true,
                                message: 'Weekly sync completed'
                            })
                    });
                }
                return Promise.resolve({
                    ok: true,
                    json: async ()=>({
                            syncState: {},
                            activityCount: 100,
                            canSync: true
                        })
                });
            });
            const { result } = (0, _react.renderHook)(()=>(0, _usestravasync.useStravaSync)(), {
                wrapper: createWrapper()
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isLoadingStatus).toBe(false);
            }, {
                timeout: 5000
            });
            result.current.syncLastWeek();
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSyncing).toBe(false);
            });
        });
        it('should trigger full sync with correct parameters', async ()=>{
            mockFetch.mockImplementation((url, options)=>{
                if (url === '/api/strava/sync' && options?.method === 'POST') {
                    const body = JSON.parse(options.body);
                    expect(body).toEqual({
                        forceRefresh: true,
                        maxActivities: 200,
                        sinceDays: 90
                    });
                    return Promise.resolve({
                        ok: true,
                        json: async ()=>({
                                success: true,
                                message: 'Full sync completed'
                            })
                    });
                }
                return Promise.resolve({
                    ok: true,
                    json: async ()=>({
                            syncState: {},
                            activityCount: 100,
                            canSync: true
                        })
                });
            });
            const { result } = (0, _react.renderHook)(()=>(0, _usestravasync.useStravaSync)(), {
                wrapper: createWrapper()
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isLoadingStatus).toBe(false);
            }, {
                timeout: 5000
            });
            result.current.forceFullSync();
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSyncing).toBe(false);
            });
        });
        it('should handle sync errors', async ()=>{
            mockFetch.mockImplementation((url, options)=>{
                if (url === '/api/strava/sync' && options?.method === 'POST') {
                    return Promise.resolve({
                        ok: false,
                        status: 422,
                        json: async ()=>({
                                success: false,
                                message: 'Sync failed',
                                errors: [
                                    'Token expired'
                                ]
                            })
                    });
                }
                return Promise.resolve({
                    ok: true,
                    json: async ()=>({
                            syncState: {},
                            activityCount: 100,
                            canSync: true
                        })
                });
            });
            const { result } = (0, _react.renderHook)(()=>(0, _usestravasync.useStravaSync)(), {
                wrapper: createWrapper()
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isLoadingStatus).toBe(false);
            }, {
                timeout: 5000
            });
            result.current.syncLatest();
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSyncing).toBe(false);
            });
            expect(result.current.syncError).toBeTruthy();
        });
    });
    describe('custom sync', ()=>{
        it('should trigger custom sync with provided options', async ()=>{
            const customOptions = {
                sinceDays: 14,
                maxActivities: 75,
                forceRefresh: true
            };
            mockFetch.mockImplementation((url, options)=>{
                if (url === '/api/strava/sync' && options?.method === 'POST') {
                    const body = JSON.parse(options.body);
                    expect(body).toEqual(customOptions);
                    return Promise.resolve({
                        ok: true,
                        json: async ()=>({
                                success: true,
                                message: 'Custom sync completed'
                            })
                    });
                }
                return Promise.resolve({
                    ok: true,
                    json: async ()=>({
                            syncState: {},
                            activityCount: 100,
                            canSync: true
                        })
                });
            });
            const { result } = (0, _react.renderHook)(()=>(0, _usestravasync.useStravaSync)(), {
                wrapper: createWrapper()
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.isLoadingStatus).toBe(false);
            }, {
                timeout: 5000
            });
            result.current.customSync(customOptions);
            await (0, _react.waitFor)(()=>{
                expect(result.current.isSyncing).toBe(false);
            });
        });
    });
});
describe('useSyncStatusInfo', ()=>{
    beforeEach(()=>{
        mockFetch.mockClear();
    });
    it('should format sync status info correctly', async ()=>{
        // First verify that useSyncStatusInfo is a function
        expect(typeof _usestravasync.useSyncStatusInfo).toBe('function');
        const mockSyncStatus = {
            syncState: {
                last_activity_sync: new Date(Date.now() - 30 * 60 * 1000).toISOString(),
                sync_enabled: true,
                sync_requests_today: 3,
                consecutive_errors: 0,
                last_error_message: null
            },
            activityCount: 125,
            canSync: true
        };
        mockFetch.mockResolvedValue({
            ok: true,
            json: async ()=>mockSyncStatus
        });
        const { result } = (0, _react.renderHook)(()=>(0, _usestravasync.useSyncStatusInfo)(), {
            wrapper: createWrapper()
        });
        await (0, _react.waitFor)(()=>{
            expect(result.current.lastSyncText).toBe('30 minutes ago');
        });
        expect(result.current.canSync).toBe(true);
        expect(result.current.activityCount).toBe(125);
        expect(result.current.todaySyncs).toBe(3);
        expect(result.current.maxSyncs).toBe(5);
        expect(result.current.consecutiveErrors).toBe(0);
    });
    it('should handle never synced status', async ()=>{
        mockFetch.mockResolvedValue({
            ok: true,
            json: async ()=>({
                    syncState: null,
                    activityCount: 0,
                    canSync: true
                })
        });
        const { result } = (0, _react.renderHook)(()=>(0, _usestravasync.useSyncStatusInfo)(), {
            wrapper: createWrapper()
        });
        await (0, _react.waitFor)(()=>{
            expect(result.current.lastSyncText).toBe('Never synced');
        });
        expect(result.current.canSync).toBe(true);
        expect(result.current.activityCount).toBe(0);
    });
    it('should format recent sync times correctly', async ()=>{
        const testCases = [
            {
                ago: 30 * 1000,
                expected: 'Just now'
            },
            {
                ago: 5 * 60 * 1000,
                expected: '5 minutes ago'
            },
            {
                ago: 2 * 60 * 60 * 1000,
                expected: '2 hours ago'
            },
            {
                ago: 24 * 60 * 60 * 1000,
                expected: 'Yesterday'
            }
        ];
        for (const testCase of testCases){
            const mockSyncStatus = {
                syncState: {
                    last_activity_sync: new Date(Date.now() - testCase.ago).toISOString(),
                    sync_enabled: true,
                    sync_requests_today: 1,
                    consecutive_errors: 0
                },
                activityCount: 100,
                canSync: true
            };
            mockFetch.mockResolvedValue({
                ok: true,
                json: async ()=>mockSyncStatus
            });
            const { result } = (0, _react.renderHook)(()=>(0, _usestravasync.useSyncStatusInfo)(), {
                wrapper: createWrapper()
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.lastSyncText).toBe(testCase.expected);
            });
        }
    });
    it('should identify sync disabled reasons', async ()=>{
        // Test rate limit exceeded
        const rateLimitStatus = {
            syncState: {
                sync_enabled: true,
                sync_requests_today: 5,
                last_activity_sync: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString()
            },
            activityCount: 100,
            canSync: false
        };
        mockFetch.mockResolvedValue({
            ok: true,
            json: async ()=>rateLimitStatus
        });
        const { result } = (0, _react.renderHook)(()=>(0, _usestravasync.useSyncStatusInfo)(), {
            wrapper: createWrapper()
        });
        await (0, _react.waitFor)(()=>{
            expect(result.current.syncDisabledReason).toBe('Daily sync limit reached (5/day)');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdGlhbWFcXERlc2t0b3BcXENvZGluZ1xcZW5kdXJvcmV2YW1wXFxfX3Rlc3RzX19cXGhvb2tzXFx1c2Utc3RyYXZhLXN5bmMudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVySG9vaywgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnXHJcbmltcG9ydCB7IFF1ZXJ5Q2xpZW50LCBRdWVyeUNsaWVudFByb3ZpZGVyIH0gZnJvbSAnQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5J1xyXG5pbXBvcnQgeyB1c2VTdHJhdmFTeW5jLCB1c2VTeW5jU3RhdHVzSW5mbyB9IGZyb20gJ0AvaG9va3MvdXNlLXN0cmF2YS1zeW5jJ1xyXG5pbXBvcnQgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCdcclxuXHJcbi8vIE1vY2sgZmV0Y2ggZ2xvYmFsbHlcclxuZ2xvYmFsLmZldGNoID0gamVzdC5mbigpXHJcblxyXG5jb25zdCBtb2NrRmV0Y2ggPSBmZXRjaCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBmZXRjaD5cclxuXHJcbi8vIENyZWF0ZSBhIHdyYXBwZXIgZm9yIFJlYWN0IFF1ZXJ5XHJcbmNvbnN0IGNyZWF0ZVdyYXBwZXIgPSAoKSA9PiB7XHJcbiAgY29uc3QgcXVlcnlDbGllbnQgPSBuZXcgUXVlcnlDbGllbnQoe1xyXG4gICAgZGVmYXVsdE9wdGlvbnM6IHtcclxuICAgICAgcXVlcmllczoge1xyXG4gICAgICAgIHJldHJ5OiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgICAgbXV0YXRpb25zOiB7XHJcbiAgICAgICAgcmV0cnk6IGZhbHNlLFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9KVxyXG5cclxuICByZXR1cm4gKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pID0+IChcclxuICAgIDxRdWVyeUNsaWVudFByb3ZpZGVyIGNsaWVudD17cXVlcnlDbGllbnR9PlxyXG4gICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L1F1ZXJ5Q2xpZW50UHJvdmlkZXI+XHJcbiAgKVxyXG59XHJcblxyXG5kZXNjcmliZSgndXNlU3RyYXZhU3luYycsICgpID0+IHtcclxuICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKVxyXG4gIH0pXHJcblxyXG4gIGFmdGVyRWFjaCgoKSA9PiB7XHJcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKVxyXG4gIH0pXHJcblxyXG4gIGRlc2NyaWJlKCdzeW5jIHN0YXR1cycsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgZmV0Y2ggc3luYyBzdGF0dXMgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBtb2NrU3luY1N0YXR1cyA9IHtcclxuICAgICAgICBzeW5jU3RhdGU6IHtcclxuICAgICAgICAgIHVzZXJfaWQ6ICd0ZXN0LXVzZXInLFxyXG4gICAgICAgICAgc3luY19lbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgc3luY19yZXF1ZXN0c190b2RheTogMixcclxuICAgICAgICAgIGxhc3RfYWN0aXZpdHlfc3luYzogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDIgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSwgLy8gMiBob3VycyBhZ29cclxuICAgICAgICAgIGNvbnNlY3V0aXZlX2Vycm9yczogMCxcclxuICAgICAgICAgIGxhc3RfZXJyb3JfbWVzc2FnZTogbnVsbFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aXZpdHlDb3VudDogMTUwLFxyXG4gICAgICAgIGNhblN5bmM6IHRydWVcclxuICAgICAgfVxyXG5cclxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XHJcbiAgICAgICAgb2s6IHRydWUsXHJcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1N5bmNTdGF0dXMsXHJcbiAgICAgIH0gYXMgUmVzcG9uc2UpXHJcblxyXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTdHJhdmFTeW5jKCksIHtcclxuICAgICAgICB3cmFwcGVyOiBjcmVhdGVXcmFwcGVyKCksXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNMb2FkaW5nU3RhdHVzKS50b0JlKGZhbHNlKVxyXG4gICAgICB9LCB7IHRpbWVvdXQ6IDUwMDAgfSlcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzKS50b0VxdWFsKG1vY2tTeW5jU3RhdHVzKVxyXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9zdHJhdmEvc3luYycpXHJcbiAgICB9KVxyXG5cclxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHN5bmMgc3RhdHVzIGVycm9yJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcclxuICAgICAgICBvazogZmFsc2UsXHJcbiAgICAgICAgc3RhdHVzOiA1MDAsXHJcbiAgICAgIH0gYXMgUmVzcG9uc2UpXHJcblxyXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTdHJhdmFTeW5jKCksIHtcclxuICAgICAgICB3cmFwcGVyOiBjcmVhdGVXcmFwcGVyKCksXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNMb2FkaW5nU3RhdHVzKS50b0JlKGZhbHNlKVxyXG4gICAgICB9LCB7IHRpbWVvdXQ6IDUwMDAgfSlcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zdGF0dXNFcnJvcikudG9CZVRydXRoeSgpXHJcbiAgICB9KVxyXG4gIH0pXHJcblxyXG4gIGRlc2NyaWJlKCdzeW5jIHRyaWdnZXJzJywgKCkgPT4ge1xyXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBzeW5jIHN0YXR1c1xyXG4gICAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uKCh1cmwpID0+IHtcclxuICAgICAgICBpZiAodXJsID09PSAnL2FwaS9zdHJhdmEvc3luYycgJiYgdHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgICBvazogdHJ1ZSxcclxuICAgICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcclxuICAgICAgICAgICAgICBzeW5jU3RhdGU6IHsgc3luY19lbmFibGVkOiB0cnVlLCBzeW5jX3JlcXVlc3RzX3RvZGF5OiAwIH0sXHJcbiAgICAgICAgICAgICAgYWN0aXZpdHlDb3VudDogMTAwLFxyXG4gICAgICAgICAgICAgIGNhblN5bmM6IHRydWVcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICB9IGFzIFJlc3BvbnNlKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdVbmtub3duIFVSTCcpKVxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuXHJcbiAgICBpdCgnc2hvdWxkIHRyaWdnZXIgbGF0ZXN0IHN5bmMgd2l0aCBjb3JyZWN0IHBhcmFtZXRlcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vY2tTeW5jUmVzdWx0ID0ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgbWVzc2FnZTogJ1N5bmMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseScsXHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgYWN0aXZpdGllc1Byb2Nlc3NlZDogMTUsXHJcbiAgICAgICAgICBuZXdBY3Rpdml0aWVzOiAxMCxcclxuICAgICAgICAgIHVwZGF0ZWRBY3Rpdml0aWVzOiA1LFxyXG4gICAgICAgICAgc3luY0R1cmF0aW9uOiAyNTAwXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uKCh1cmwsIG9wdGlvbnMpID0+IHtcclxuICAgICAgICBpZiAodXJsID09PSAnL2FwaS9zdHJhdmEvc3luYycgJiYgb3B0aW9ucz8ubWV0aG9kID09PSAnUE9TVCcpIHtcclxuICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnBhcnNlKG9wdGlvbnMuYm9keSBhcyBzdHJpbmcpXHJcbiAgICAgICAgICBleHBlY3QoYm9keSkudG9FcXVhbCh7IG1heEFjdGl2aXRpZXM6IDUwIH0pXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgICBvazogdHJ1ZSxcclxuICAgICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1N5bmNSZXN1bHQsXHJcbiAgICAgICAgICB9IGFzIFJlc3BvbnNlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBEZWZhdWx0IHRvIHN5bmMgc3RhdHVzIHJlc3BvbnNlXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICBvazogdHJ1ZSxcclxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XHJcbiAgICAgICAgICAgIHN5bmNTdGF0ZTogeyBzeW5jX2VuYWJsZWQ6IHRydWUgfSxcclxuICAgICAgICAgICAgYWN0aXZpdHlDb3VudDogMTAwLFxyXG4gICAgICAgICAgICBjYW5TeW5jOiB0cnVlXHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICB9IGFzIFJlc3BvbnNlKVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU3RyYXZhU3luYygpLCB7XHJcbiAgICAgICAgd3JhcHBlcjogY3JlYXRlV3JhcHBlcigpLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZ1N0YXR1cykudG9CZShmYWxzZSlcclxuICAgICAgfSwgeyB0aW1lb3V0OiA1MDAwIH0pXHJcblxyXG4gICAgICAvLyBUcmlnZ2VyIHN5bmNcclxuICAgICAgcmVzdWx0LmN1cnJlbnQuc3luY0xhdGVzdCgpXHJcblxyXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTeW5jaW5nKS50b0JlKGZhbHNlKVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN5bmNSZXN1bHQpLnRvRXF1YWwobW9ja1N5bmNSZXN1bHQpXHJcbiAgICB9KVxyXG5cclxuICAgIGl0KCdzaG91bGQgdHJpZ2dlciB3ZWVrbHkgc3luYyB3aXRoIGNvcnJlY3QgcGFyYW1ldGVycycsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbigodXJsLCBvcHRpb25zKSA9PiB7XHJcbiAgICAgICAgaWYgKHVybCA9PT0gJy9hcGkvc3RyYXZhL3N5bmMnICYmIG9wdGlvbnM/Lm1ldGhvZCA9PT0gJ1BPU1QnKSB7XHJcbiAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5wYXJzZShvcHRpb25zLmJvZHkgYXMgc3RyaW5nKVxyXG4gICAgICAgICAgZXhwZWN0KGJvZHkpLnRvRXF1YWwoeyBzaW5jZURheXM6IDcsIG1heEFjdGl2aXRpZXM6IDEwMCB9KVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgICAgb2s6IHRydWUsXHJcbiAgICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2U6ICdXZWVrbHkgc3luYyBjb21wbGV0ZWQnIH0pLFxyXG4gICAgICAgICAgfSBhcyBSZXNwb25zZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICBvazogdHJ1ZSxcclxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN5bmNTdGF0ZToge30sIGFjdGl2aXR5Q291bnQ6IDEwMCwgY2FuU3luYzogdHJ1ZSB9KSxcclxuICAgICAgICB9IGFzIFJlc3BvbnNlKVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU3RyYXZhU3luYygpLCB7XHJcbiAgICAgICAgd3JhcHBlcjogY3JlYXRlV3JhcHBlcigpLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZ1N0YXR1cykudG9CZShmYWxzZSlcclxuICAgICAgfSwgeyB0aW1lb3V0OiA1MDAwIH0pXHJcblxyXG4gICAgICByZXN1bHQuY3VycmVudC5zeW5jTGFzdFdlZWsoKVxyXG5cclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU3luY2luZykudG9CZShmYWxzZSlcclxuICAgICAgfSlcclxuICAgIH0pXHJcblxyXG4gICAgaXQoJ3Nob3VsZCB0cmlnZ2VyIGZ1bGwgc3luYyB3aXRoIGNvcnJlY3QgcGFyYW1ldGVycycsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbigodXJsLCBvcHRpb25zKSA9PiB7XHJcbiAgICAgICAgaWYgKHVybCA9PT0gJy9hcGkvc3RyYXZhL3N5bmMnICYmIG9wdGlvbnM/Lm1ldGhvZCA9PT0gJ1BPU1QnKSB7XHJcbiAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5wYXJzZShvcHRpb25zLmJvZHkgYXMgc3RyaW5nKVxyXG4gICAgICAgICAgZXhwZWN0KGJvZHkpLnRvRXF1YWwoeyBcclxuICAgICAgICAgICAgZm9yY2VSZWZyZXNoOiB0cnVlLCBcclxuICAgICAgICAgICAgbWF4QWN0aXZpdGllczogMjAwLFxyXG4gICAgICAgICAgICBzaW5jZURheXM6IDkwIFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgIG9rOiB0cnVlLFxyXG4gICAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiAnRnVsbCBzeW5jIGNvbXBsZXRlZCcgfSksXHJcbiAgICAgICAgICB9IGFzIFJlc3BvbnNlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgIG9rOiB0cnVlLFxyXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3luY1N0YXRlOiB7fSwgYWN0aXZpdHlDb3VudDogMTAwLCBjYW5TeW5jOiB0cnVlIH0pLFxyXG4gICAgICAgIH0gYXMgUmVzcG9uc2UpXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTdHJhdmFTeW5jKCksIHtcclxuICAgICAgICB3cmFwcGVyOiBjcmVhdGVXcmFwcGVyKCksXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNMb2FkaW5nU3RhdHVzKS50b0JlKGZhbHNlKVxyXG4gICAgICB9LCB7IHRpbWVvdXQ6IDUwMDAgfSlcclxuXHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LmZvcmNlRnVsbFN5bmMoKVxyXG5cclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU3luY2luZykudG9CZShmYWxzZSlcclxuICAgICAgfSlcclxuICAgIH0pXHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc3luYyBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tGZXRjaC5tb2NrSW1wbGVtZW50YXRpb24oKHVybCwgb3B0aW9ucykgPT4ge1xyXG4gICAgICAgIGlmICh1cmwgPT09ICcvYXBpL3N0cmF2YS9zeW5jJyAmJiBvcHRpb25zPy5tZXRob2QgPT09ICdQT1NUJykge1xyXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcclxuICAgICAgICAgICAgc3RhdHVzOiA0MjIsXHJcbiAgICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IFxyXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcclxuICAgICAgICAgICAgICBtZXNzYWdlOiAnU3luYyBmYWlsZWQnLCBcclxuICAgICAgICAgICAgICBlcnJvcnM6IFsnVG9rZW4gZXhwaXJlZCddIFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgIH0gYXMgUmVzcG9uc2UpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgb2s6IHRydWUsXHJcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzeW5jU3RhdGU6IHt9LCBhY3Rpdml0eUNvdW50OiAxMDAsIGNhblN5bmM6IHRydWUgfSksXHJcbiAgICAgICAgfSBhcyBSZXNwb25zZSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVN0cmF2YVN5bmMoKSwge1xyXG4gICAgICAgIHdyYXBwZXI6IGNyZWF0ZVdyYXBwZXIoKSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmdTdGF0dXMpLnRvQmUoZmFsc2UpXHJcbiAgICAgIH0sIHsgdGltZW91dDogNTAwMCB9KVxyXG5cclxuICAgICAgcmVzdWx0LmN1cnJlbnQuc3luY0xhdGVzdCgpXHJcblxyXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTeW5jaW5nKS50b0JlKGZhbHNlKVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN5bmNFcnJvcikudG9CZVRydXRoeSgpXHJcbiAgICB9KVxyXG4gIH0pXHJcblxyXG4gIGRlc2NyaWJlKCdjdXN0b20gc3luYycsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgdHJpZ2dlciBjdXN0b20gc3luYyB3aXRoIHByb3ZpZGVkIG9wdGlvbnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGN1c3RvbU9wdGlvbnMgPSB7XHJcbiAgICAgICAgc2luY2VEYXlzOiAxNCxcclxuICAgICAgICBtYXhBY3Rpdml0aWVzOiA3NSxcclxuICAgICAgICBmb3JjZVJlZnJlc2g6IHRydWVcclxuICAgICAgfVxyXG5cclxuICAgICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbigodXJsLCBvcHRpb25zKSA9PiB7XHJcbiAgICAgICAgaWYgKHVybCA9PT0gJy9hcGkvc3RyYXZhL3N5bmMnICYmIG9wdGlvbnM/Lm1ldGhvZCA9PT0gJ1BPU1QnKSB7XHJcbiAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5wYXJzZShvcHRpb25zLmJvZHkgYXMgc3RyaW5nKVxyXG4gICAgICAgICAgZXhwZWN0KGJvZHkpLnRvRXF1YWwoY3VzdG9tT3B0aW9ucylcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgIG9rOiB0cnVlLFxyXG4gICAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiAnQ3VzdG9tIHN5bmMgY29tcGxldGVkJyB9KSxcclxuICAgICAgICAgIH0gYXMgUmVzcG9uc2UpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgb2s6IHRydWUsXHJcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzeW5jU3RhdGU6IHt9LCBhY3Rpdml0eUNvdW50OiAxMDAsIGNhblN5bmM6IHRydWUgfSksXHJcbiAgICAgICAgfSBhcyBSZXNwb25zZSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVN0cmF2YVN5bmMoKSwge1xyXG4gICAgICAgIHdyYXBwZXI6IGNyZWF0ZVdyYXBwZXIoKSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmdTdGF0dXMpLnRvQmUoZmFsc2UpXHJcbiAgICAgIH0sIHsgdGltZW91dDogNTAwMCB9KVxyXG5cclxuICAgICAgcmVzdWx0LmN1cnJlbnQuY3VzdG9tU3luYyhjdXN0b21PcHRpb25zKVxyXG5cclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU3luY2luZykudG9CZShmYWxzZSlcclxuICAgICAgfSlcclxuICAgIH0pXHJcbiAgfSlcclxufSlcclxuXHJcbmRlc2NyaWJlKCd1c2VTeW5jU3RhdHVzSW5mbycsICgpID0+IHtcclxuICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKVxyXG4gIH0pXHJcblxyXG4gIGl0KCdzaG91bGQgZm9ybWF0IHN5bmMgc3RhdHVzIGluZm8gY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gRmlyc3QgdmVyaWZ5IHRoYXQgdXNlU3luY1N0YXR1c0luZm8gaXMgYSBmdW5jdGlvblxyXG4gICAgZXhwZWN0KHR5cGVvZiB1c2VTeW5jU3RhdHVzSW5mbykudG9CZSgnZnVuY3Rpb24nKVxyXG4gICAgXHJcbiAgICBjb25zdCBtb2NrU3luY1N0YXR1cyA9IHtcclxuICAgICAgc3luY1N0YXRlOiB7XHJcbiAgICAgICAgbGFzdF9hY3Rpdml0eV9zeW5jOiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMzAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksIC8vIDMwIG1pbnV0ZXMgYWdvXHJcbiAgICAgICAgc3luY19lbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIHN5bmNfcmVxdWVzdHNfdG9kYXk6IDMsXHJcbiAgICAgICAgY29uc2VjdXRpdmVfZXJyb3JzOiAwLFxyXG4gICAgICAgIGxhc3RfZXJyb3JfbWVzc2FnZTogbnVsbFxyXG4gICAgICB9LFxyXG4gICAgICBhY3Rpdml0eUNvdW50OiAxMjUsXHJcbiAgICAgIGNhblN5bmM6IHRydWVcclxuICAgIH1cclxuXHJcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICBvazogdHJ1ZSxcclxuICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1N5bmNTdGF0dXMsXHJcbiAgICB9IGFzIFJlc3BvbnNlKVxyXG5cclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVN5bmNTdGF0dXNJbmZvKCksIHtcclxuICAgICAgd3JhcHBlcjogY3JlYXRlV3JhcHBlcigpLFxyXG4gICAgfSlcclxuXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lmxhc3RTeW5jVGV4dCkudG9CZSgnMzAgbWludXRlcyBhZ28nKVxyXG4gICAgfSlcclxuXHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuY2FuU3luYykudG9CZSh0cnVlKVxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmFjdGl2aXR5Q291bnQpLnRvQmUoMTI1KVxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnRvZGF5U3luY3MpLnRvQmUoMylcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5tYXhTeW5jcykudG9CZSg1KVxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmNvbnNlY3V0aXZlRXJyb3JzKS50b0JlKDApXHJcbiAgfSlcclxuXHJcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgbmV2ZXIgc3luY2VkIHN0YXR1cycsIGFzeW5jICgpID0+IHtcclxuICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgIG9rOiB0cnVlLFxyXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xyXG4gICAgICAgIHN5bmNTdGF0ZTogbnVsbCxcclxuICAgICAgICBhY3Rpdml0eUNvdW50OiAwLFxyXG4gICAgICAgIGNhblN5bmM6IHRydWVcclxuICAgICAgfSksXHJcbiAgICB9IGFzIFJlc3BvbnNlKVxyXG5cclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVN5bmNTdGF0dXNJbmZvKCksIHtcclxuICAgICAgd3JhcHBlcjogY3JlYXRlV3JhcHBlcigpLFxyXG4gICAgfSlcclxuXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lmxhc3RTeW5jVGV4dCkudG9CZSgnTmV2ZXIgc3luY2VkJylcclxuICAgIH0pXHJcblxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmNhblN5bmMpLnRvQmUodHJ1ZSlcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5hY3Rpdml0eUNvdW50KS50b0JlKDApXHJcbiAgfSlcclxuXHJcbiAgaXQoJ3Nob3VsZCBmb3JtYXQgcmVjZW50IHN5bmMgdGltZXMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICBjb25zdCB0ZXN0Q2FzZXMgPSBbXHJcbiAgICAgICB7IGFnbzogMzAgKiAxMDAwLCBleHBlY3RlZDogJ0p1c3Qgbm93JyB9LCAvLyAzMCBzZWNvbmRzXHJcbiAgICAgICB7IGFnbzogNSAqIDYwICogMTAwMCwgZXhwZWN0ZWQ6ICc1IG1pbnV0ZXMgYWdvJyB9LCAvLyA1IG1pbnV0ZXNcclxuICAgICAgIHsgYWdvOiAyICogNjAgKiA2MCAqIDEwMDAsIGV4cGVjdGVkOiAnMiBob3VycyBhZ28nIH0sIC8vIDIgaG91cnNcclxuICAgICAgIHsgYWdvOiAyNCAqIDYwICogNjAgKiAxMDAwLCBleHBlY3RlZDogJ1llc3RlcmRheScgfSwgLy8gMSBkYXkgKGZvcm1hdHRlZCBhcyBZZXN0ZXJkYXkpXHJcbiAgICAgXVxyXG5cclxuICAgIGZvciAoY29uc3QgdGVzdENhc2Ugb2YgdGVzdENhc2VzKSB7XHJcbiAgICAgIGNvbnN0IG1vY2tTeW5jU3RhdHVzID0ge1xyXG4gICAgICAgIHN5bmNTdGF0ZToge1xyXG4gICAgICAgICAgbGFzdF9hY3Rpdml0eV9zeW5jOiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gdGVzdENhc2UuYWdvKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgc3luY19lbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgc3luY19yZXF1ZXN0c190b2RheTogMSxcclxuICAgICAgICAgIGNvbnNlY3V0aXZlX2Vycm9yczogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aXZpdHlDb3VudDogMTAwLFxyXG4gICAgICAgIGNhblN5bmM6IHRydWVcclxuICAgICAgfVxyXG5cclxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICBvazogdHJ1ZSxcclxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrU3luY1N0YXR1cyxcclxuICAgICAgfSBhcyBSZXNwb25zZSlcclxuXHJcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVN5bmNTdGF0dXNJbmZvKCksIHtcclxuICAgICAgICB3cmFwcGVyOiBjcmVhdGVXcmFwcGVyKCksXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubGFzdFN5bmNUZXh0KS50b0JlKHRlc3RDYXNlLmV4cGVjdGVkKVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH0pXHJcblxyXG4gIGl0KCdzaG91bGQgaWRlbnRpZnkgc3luYyBkaXNhYmxlZCByZWFzb25zJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gVGVzdCByYXRlIGxpbWl0IGV4Y2VlZGVkXHJcbiAgICBjb25zdCByYXRlTGltaXRTdGF0dXMgPSB7XHJcbiAgICAgIHN5bmNTdGF0ZToge1xyXG4gICAgICAgIHN5bmNfZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICBzeW5jX3JlcXVlc3RzX3RvZGF5OiA1LCAvLyBBdCBsaW1pdFxyXG4gICAgICAgIGxhc3RfYWN0aXZpdHlfc3luYzogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDIgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKVxyXG4gICAgICB9LFxyXG4gICAgICBhY3Rpdml0eUNvdW50OiAxMDAsXHJcbiAgICAgIGNhblN5bmM6IGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgb2s6IHRydWUsXHJcbiAgICAgIGpzb246IGFzeW5jICgpID0+IHJhdGVMaW1pdFN0YXR1cyxcclxuICAgIH0gYXMgUmVzcG9uc2UpXHJcblxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU3luY1N0YXR1c0luZm8oKSwge1xyXG4gICAgICB3cmFwcGVyOiBjcmVhdGVXcmFwcGVyKCksXHJcbiAgICB9KVxyXG5cclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3luY0Rpc2FibGVkUmVhc29uKS50b0JlKCdEYWlseSBzeW5jIGxpbWl0IHJlYWNoZWQgKDUvZGF5KScpXHJcbiAgICB9KVxyXG4gIH0pXHJcbn0pICJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmZXRjaCIsImplc3QiLCJmbiIsIm1vY2tGZXRjaCIsImNyZWF0ZVdyYXBwZXIiLCJxdWVyeUNsaWVudCIsIlF1ZXJ5Q2xpZW50IiwiZGVmYXVsdE9wdGlvbnMiLCJxdWVyaWVzIiwicmV0cnkiLCJtdXRhdGlvbnMiLCJjaGlsZHJlbiIsIlF1ZXJ5Q2xpZW50UHJvdmlkZXIiLCJjbGllbnQiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJtb2NrQ2xlYXIiLCJhZnRlckVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJtb2NrU3luY1N0YXR1cyIsInN5bmNTdGF0ZSIsInVzZXJfaWQiLCJzeW5jX2VuYWJsZWQiLCJzeW5jX3JlcXVlc3RzX3RvZGF5IiwibGFzdF9hY3Rpdml0eV9zeW5jIiwiRGF0ZSIsIm5vdyIsInRvSVNPU3RyaW5nIiwiY29uc2VjdXRpdmVfZXJyb3JzIiwibGFzdF9lcnJvcl9tZXNzYWdlIiwiYWN0aXZpdHlDb3VudCIsImNhblN5bmMiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJvayIsImpzb24iLCJyZXN1bHQiLCJyZW5kZXJIb29rIiwidXNlU3RyYXZhU3luYyIsIndyYXBwZXIiLCJ3YWl0Rm9yIiwiZXhwZWN0IiwiY3VycmVudCIsImlzTG9hZGluZ1N0YXR1cyIsInRvQmUiLCJ0aW1lb3V0Iiwic3luY1N0YXR1cyIsInRvRXF1YWwiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInN0YXR1cyIsInN0YXR1c0Vycm9yIiwidG9CZVRydXRoeSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsInVybCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiRXJyb3IiLCJtb2NrU3luY1Jlc3VsdCIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwiZGF0YSIsImFjdGl2aXRpZXNQcm9jZXNzZWQiLCJuZXdBY3Rpdml0aWVzIiwidXBkYXRlZEFjdGl2aXRpZXMiLCJzeW5jRHVyYXRpb24iLCJvcHRpb25zIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJwYXJzZSIsIm1heEFjdGl2aXRpZXMiLCJzeW5jTGF0ZXN0IiwiaXNTeW5jaW5nIiwic3luY1Jlc3VsdCIsInNpbmNlRGF5cyIsInN5bmNMYXN0V2VlayIsImZvcmNlUmVmcmVzaCIsImZvcmNlRnVsbFN5bmMiLCJlcnJvcnMiLCJzeW5jRXJyb3IiLCJjdXN0b21PcHRpb25zIiwiY3VzdG9tU3luYyIsInVzZVN5bmNTdGF0dXNJbmZvIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJsYXN0U3luY1RleHQiLCJ0b2RheVN5bmNzIiwibWF4U3luY3MiLCJjb25zZWN1dGl2ZUVycm9ycyIsInRlc3RDYXNlcyIsImFnbyIsImV4cGVjdGVkIiwidGVzdENhc2UiLCJyYXRlTGltaXRTdGF0dXMiLCJzeW5jRGlzYWJsZWRSZWFzb24iXSwibWFwcGluZ3MiOiI7Ozs7O3VCQUFvQzs0QkFDYTsrQkFDQTtBQUdqRCxzQkFBc0I7QUFDdEJBLE9BQU9DLEtBQUssR0FBR0MsS0FBS0MsRUFBRTtBQUV0QixNQUFNQyxZQUFZSDtBQUVsQixtQ0FBbUM7QUFDbkMsTUFBTUksZ0JBQWdCO0lBQ3BCLE1BQU1DLGNBQWMsSUFBSUMsdUJBQVcsQ0FBQztRQUNsQ0MsZ0JBQWdCO1lBQ2RDLFNBQVM7Z0JBQ1BDLE9BQU87WUFDVDtZQUNBQyxXQUFXO2dCQUNURCxPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBRUEsT0FBTyxDQUFDLEVBQUVFLFFBQVEsRUFBMkIsaUJBQzNDLHFCQUFDQywrQkFBbUI7WUFBQ0MsUUFBUVI7c0JBQzFCTTs7QUFHUDtBQUVBRyxTQUFTLGlCQUFpQjtJQUN4QkMsV0FBVztRQUNUWixVQUFVYSxTQUFTO0lBQ3JCO0lBRUFDLFVBQVU7UUFDUmhCLEtBQUtpQixhQUFhO0lBQ3BCO0lB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